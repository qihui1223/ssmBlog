/*
Navicat MySQL Data Transfer

Source Server         : 本机
Source Server Version : 50721
Source Host           : localhost:3306
Source Database       : db_shiro

Target Server Type    : MYSQL
Target Server Version : 50721
File Encoding         : 65001

Date: 2019-06-17 09:23:20
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for `blog`
-- ----------------------------
DROP TABLE IF EXISTS `blog`;
CREATE TABLE `blog` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(255) NOT NULL COMMENT '标题',
  `content` text NOT NULL COMMENT 'html文本',
  `md` text COMMENT 'markDown文本',
  `dId` int(11) NOT NULL COMMENT '分类id',
  `createdtime` datetime DEFAULT NULL COMMENT '创建时间',
  `updatetime` datetime DEFAULT NULL COMMENT '修改时间',
  `status` int(11) NOT NULL DEFAULT '0' COMMENT '状态: 0为显示,1为隐藏',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=31 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of blog
-- ----------------------------
INSERT INTO `blog` VALUES ('16', 'java基础(二) 基础知识', '<h4 id=\"h4-1-\"><a name=\"1.常量和变量\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.常量和变量</h4><ul>\n<li><strong>什么是常量?</strong><br>  值不会变的是常量<br>  常量在程序运行时是不能被修改的。</li><li><strong>什么是变量?</strong><br>  在作用域之间,在该数据类型范围内可以变化的的一个量.</li></ul>\n<ul>\n<li>声明变量(定义变量)<pre><code>  格式: 数据类型 变量名;\n</code></pre></li><li>变量赋值:<pre><code>  变量名 = 常量名;\n  数据类型 变量名 = 常量名;\n</code></pre></li></ul>\n<h4 id=\"h4-2-\"><a name=\"2.进制\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.进制</h4><ul>\n<li><strong>二进制</strong><br>  0和1 前缀0B或者0b 比如：0B1001 转为十进制是9</li><li><strong>八进制</strong><br>  0-7 前缀0 比如：0103</li></ul>\n<ul>\n<li>十进制【我们常用的】<br>  0-9 没有前缀</li></ul>\n<ul>\n<li><strong>十进制</strong><br>  0-9 和 A-F 前缀0x或者0X 比如：0x123</li><li><strong>进制转换</strong><br>  任何进制转化为十进制公式：系数 <em> 底数 ^ 指数<br>```java<br>0b1010 = 1 </em> 2^3 + 0 <em>2^2 + 1</em>2^1 + 0*2^0<pre><code>         = 8 + 0 + 2 + 0\n         = 10\n</code></pre></li></ul>\n<p>0123  = 1<em>8^2 + 2</em>8^1 + 3*8^0<br>           = 64 + 16 + 3<br>            = 83</p>\n<p>0x123 = 1<em>16^2 + 2</em>16^1 + 3*16^0<br>           = 256 + 32 + 3<br>           = 291</p>\n<pre><code>#### 3.反码和补码\n    正数的补码和原码是一样的\n</code></pre><pre><code>5\n原码：0000 0101\n补码：0000 0101\n    * 负数的补码是它的反码加1\n\n-5：\n原码：1000 0101\n反码：1111 1010\n    +         1\n------------------\n补码  1111 1011\n</code></pre><pre><code>#### 4.Java数据类型\n\n- **基本数据类型**\n- byte类型\n    * 1个字节，8位【-128到127之间】\n- short类型\n    * 2个字节，16位【-2^15 到 2^15 -1】\n- int类型\n    * 4个字节，32位【-2^31 到 2^31 -1】\n- float类型【浮点型】\n    * 4个字节，32位\n- double类型【浮点型】\n    * 8个字节，64位\n- long类型\n    * 8个字节，64位【-2^63  到 2^63 -1】\n- char类型\n    * 2个字节，16位【1个汉字刚好2个字节】\n- boolean类型\n    * 1个字节，true和false\n- **引用类型**\n* 在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。\n* 对象、数组都是引用数据类型。\n* 所有引用类型的默认值都是null。\n* 一个引用变量可以用来引用任何与之兼容的类型。\n* 例子：Site site = new Site(&quot;Runoob&quot;)。\n- **数据类型的转换**\n- 默认转换\n    * 1：byte,short,char—int—long—float—double\n    * 2：byte,short,char相互之间补转换，他们参与运算首先转换为int类型\n- 向上转换: 自动转化\n    * double d = 1.234f;\n- 向下转换: 需要强制转换\n    * 格式: 目标类型 变量名 = (目标类型)值或变量名\n    * int a = (int) 15.7f;\n    * 注意:\n</code></pre><pre><code>    1:在java中，任何一个整数默认为 int 类型 (1)\n    2:在java种，任何一个小数，默认为 double 类型( 1.0)\n    3:123L 或者 1231 编译器会将该数当成long类型\n    4:12.345f 或者12.345F 编译器会将该数当成float类型\n</code></pre><pre><code>\n#### 字节码\n- **常见的字节码**\n* ASCII 码\n* GBK码\n* Unicode码【占2个字节】\n\n#### 运算符\n- **常见的运算符有哪些**\n    * 算术运算符\n    * 赋值运算符\n    * 关系运算符\n    * 逻辑运算符\n    * 三目运算符\n    * 特殊运算符: 位运算符\n- **算术运算符**\n</code></pre><pre><code>+,  -,  *,  /,  %(取余), ++(自加), --(自减)\n</code></pre><pre><code>- **赋值运算符**\n</code></pre><pre><code>= ， += ， -= ， *= ， /= ， %=\n</code></pre><pre><code>- **关系运算符**\n</code></pre><pre><code>==, &gt;, &lt;, =&gt;, &lt;=, !=\n</code></pre><pre><code>- **逻辑运算符**\n</code></pre><p>&amp; ，^ ，| ，&amp;&amp; ，|| ，！ ， ^</p>\n<pre><code>- **三目运算符**\n</code></pre><pre><code>a == b ？ c ： d\n格式：(条件表达式)？表达式1：表达式2\n</code></pre><pre><code>- **位运算符**\n</code></pre><pre><code>&amp; , | , ^ , ~ , &lt;&lt; , &gt;&gt; , &gt;&gt;&gt;\n</code></pre><pre><code>\n#### Java基本语句结构\n- **语句结构种类**\n    * 顺序结构\n    * 选择结构\n    * 循环结构\n- **顺序结构**\n    * 从上到下依次执行\n- **选择结构【可以嵌套】**\n    * if ， if else ， if else if …… else\n    * switch case【支持byte，short，char，int，String】\n- **循环结构**\n* for\n</code></pre><pre><code>for(初始化语句;判断条件语句;控制条件语句) {\n         循环体语句;\n}\n第一步：先执行初始化语句，只执行一次\n第二步：执行判断条件语句\n第三部：执行循环体语句\n第四步：执行控制条件语句，然后再执行循环体语句【循环】\n</code></pre><pre><code>* while\n</code></pre><pre><code>初始化语句;\nwhile(判断条件语句) {\n    循环体语句;\n    控制条件语句;\n}\n</code></pre><pre><code>* do while\n</code></pre><pre><code>do {\n         循环体语句;\n}while((判断条件语句);\n</code></pre><pre><code>\n#### Java方法\n- **定义**\n方法就是完成特定功能的代码块\n</code></pre><p>1.系统方法，只需要会使用，不需要知道内部的结构<br>2.自定义方法: 方法内部实现需要我们来写<br>3.方法内部不能再嵌套方法</p>\n<pre><code>- **格式**\n</code></pre><pre><code>修饰符 返回类型 方法名(参数类型 参数名,...){\n    函数体\n    return 返回值\n}\n</code></pre><pre><code>* 修饰符: public static或者直接是public或是其他的private\n* 返回类型: 所有的数据类型(基本类型: int, long,float,char...,引用数据类型: String)\n* 方法名: 采用驼峰式,首字母一般小写,要见名知意\n* 参数类型: 所有的数据类型,如果一个方法没有返回值,则这个方法值类型为void\n* 参数名: 变量\n* 返回值: 即返回结果(这个结果必须与返回类型一致)\n\n#### 数组\n- **数组的概念**\n* 数组是一个容器,可以储存多个变量,这些变量的数据类型必须一致\n* 数组既可以储存基本数据类型,也可以储存引用数据类型\n\n- **一维数组**\n* 数组格式定义\n    格式一: 数据类型【】 数组名\n    格式二: 数据类型 数组名【】\n</code></pre><pre><code>int[] a; //定义了一个int类型的数组a;\nint a[]; //定义了一个int类型的a数组;\n</code></pre><pre><code>- 数组的初始化\n    * java的数组必须初始化,然后才能使用\n    * 数组初始化: 就是为数组元素中的数组分配内存空间,并为每一个数组元素赋值\n- 初始化分类\n    *  动态初始化: 只指定长度,由系统给出初始值\n    * 静态初始化: 给出初始值,由系统给出长度\n    * 注意事项: 这两种方式,只能给出一种,不能动静结合\n- **二维数组**\n* 数组定义格式\n    * 数据类型[][] 变量名 = new 数据类型[m][n];\n    * m表示这个二维数组有多少个一维数组\n    * n表示每一个一维数组的元素个数\n</code></pre><pre><code>int[][] arr = new int[3][2];\n定义了一个二维数组arr\n这个二维数组有3个一维数组，名称是arr[0],arr[1],arr[2]\n每个一维数组有2个元素，可以通过arr[m][n]来获取,\n</code></pre><p>```</p>\n<h4 id=\"h4-u6570u636Eu7ED3u6784\"><a name=\"数据结构\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>数据结构</h4><p><strong>枚举: Enumeration</strong><br><strong>位集合: BitSet</strong><br><strong>向量: Vector</strong><br><strong>栈: Stack</strong><br><strong>字典: Dictionary</strong><br><strong>哈希表: Hashtable</strong><br><strong>属性: Properties</strong></p>\n<ul>\n<li>枚举:<ul>\n<li>枚举（Enumeration）接口虽然它本身不属于数据结构,但它在其他数据结构的范畴里应用很广。 </li><li>枚举（The Enumeration）接口定义了一种从数据结构中取回连续元素的方式。</li></ul>\n</li><li>位集合（BitSet）<ul>\n<li>位集合类实现了一组可以单独设置和清除的位或标志。</li><li>该类在处理一组布尔值的时候非常有用，你只需要给每个值赋值一”位”，<br>然后对位进行适当的设置或清除，就可以对布尔值进行操作了。</li></ul>\n</li><li>向量（Vector）<ul>\n<li>向量（Vector）类和传统数组非常相似，但是Vector的大小能根据需要动态的变化。<br>和数组一样，Vector对象的元素也能通过索引访问。</li><li>使用Vector类最主要的好处就是在创建对象的时候不必给对象指定大小，它的大小会根据需要动态的变化。</li></ul>\n</li><li>栈（Stack）<ul>\n<li>栈（Stack）实现了一个后进先出（LIFO）的数据结构。</li><li>你可以把栈理解为对象的垂直分布的栈，当你添加一个新元素时，就将新元素放在其他元素的顶部。</li><li>当你从栈中取元素的时候，就从栈顶取一个元素。换句话说，最后进栈的元素最先被取出。</li><li>字典（Dictionary）<br>字典（Dictionary） 类是一个抽象类，它定义了键映射到值的数据结构。<br>当你想要通过特定的键而不是整数索引来访问数据的时候，这时候应该使用Dictionary。<br>由于Dictionary类是抽象类，所以它只提供了键映射到值的数据结构，而没有提供特定的实现。</li></ul>\n</li></ul>\n<ul>\n<li>哈希表（Hashtable）<br>Hashtable类提供了一种在用户定义键结构的基础上来组织数据的手段。<br>例如，在地址列表的哈希表中，你可以根据邮政编码作为键来存储和排序数据，而不是通过人名。<br>哈希表键的具体含义完全取决于哈希表的使用情景和它包含的数据。</li><li>属性（Properties）<br>Properties 继承于 Hashtable.Properties 类表示了一个持久的属性集.属性列表中每个键及其对应值都是一个字符串。<br>Properties 类被许多Java类使用。例如，在获取环境变量时它就作为System.getProperties()方法的返回值。</li></ul>\n', null, '1', '2019-05-09 00:00:00', '2019-05-09 15:42:16', '0');
INSERT INTO `blog` VALUES ('17', 'java基础(三) 常见的api', '<h4 id=\"h4-object-\"><a name=\"object类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>object类</h4><ul>\n<li>Object类有那些的公用方法<ul>\n<li>equals() : 判断两个对象是否相等</li><li>clone(): 进行对象拷贝</li><li>getClass(): 返回和当前对象相关的Class对象</li><li>notify(): notifyall,wait都是用来对给定对象进行线程同步的</li></ul>\n</li></ul>\n<h4 id=\"h4-string-\"><a name=\"String类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>String类</h4><ul>\n<li>String类的一些特性<ul>\n<li>String类代表字符串.java程序中所有的字符串字面值(如: “abc”)都由此类的实例实现</li><li>字符串是常量,它的值在创建之后不可以被更改.字符串缓冲区支持可变的字符串.因为String对象不可变,所以可以被共享.</li><li>java语言提供字符串串联符号(“ + “),以及将其他对象转化成字符串的特殊支持.StringBuilder（或 StringBuffer）类及其 append 方法实现的。</li></ul>\n</li><li>一旦被创建就不能改变<ul>\n<li>String s = new String(“hello”)和String s = “hello”;的区别</li><li>String的特点一旦被创建就不能改变【内容不能变，引用可以变】<br>```<br>A:String的特点: 一旦被创建就不能改变<br>B:案例演示<br>a:如何理解这句话<br>String s = “hello” ;<br>s =  “world” + “java”; 问s的结果是多少?</li></ul>\n</li></ul>\n<p>下面这条语句一共创建了多少个对象:String s = “a”+”b”+”c”; 分别都是什么？<br>答案：5个对象<br>分别是 “a” , “b” , “c” , “ab” , “abc”<br>因为字符串的特点是一旦被创建就不能被改变,所有在使用常量进行相加的时候,都是在创建新的字符串对象<br>最后在把字符串”abc”这个常量值赋值给引用变量s</p>\n<pre><code>- StringBuffer类与StringBuilder类\n    * StringBuffer类概述\n    字符串缓冲区，StringBuffer是一个容器\n    我们如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。 而StringBuffer就可以解决这个问题\n线程安全的可变的字符序列 , 安全对应的效率比较低\n    * StringBuffer和String的区别\n        String是不可变的字符序列\n        StringBuffer 是可以的字符序列\n- StringBuffer和String的相互转换\n    * String -- StringBuffer\n        * 通过构造方法\n        * 过append()方法\n    * StringBuffer -- String\n        * 使用substring方法\n        * 通过构造方法\n        * 通过toString()方法\n- StringBuilder类\n    * StringBuilder是线程不安全的，其他跟StringBuffer一样；StringBuffer和StringBuilder底层是 char[]数组实现的\n\n#### 数组\n- 冒泡排序原理\n    * 相邻的元素两两比较,大的往后放,第一次完毕后,最大值出现在最大索引处\n    * 冒泡排序代码\n</code></pre><p>/**</p>\n<ul>\n<li>冒泡排序</li><li><a href=\"https://github.com/param\" title=\"&#64;param\" class=\"at-link\">@param</a> arr<br>*/<br>private static void sort(int[] arr){<br>  for(int y = 0; y &lt; arr.length; y++){<pre><code>  for(int x = 0 ; x &lt; arr.length - 1 - y ; x++ ) {\n      if(arr[x] &gt; arr[x+1]) {\n          int temp = arr[x] ;\n          arr[x] = arr[x+1] ;\n          arr[x+1] = temp ;\n      }\n  }\n</code></pre>  }<br>}<br>```</li></ul>\n<ul>\n<li>选择排序<ul>\n<li>从0索引开始，依次和后面元素比较，小的往前放，第一次完毕，最小值出现在了最小索引处</li><li>数组高级选择排序代码实现</li></ul>\n</li></ul>\n<pre><code>private static void selectSort(int[] arr) {\n    for(int index = 0 ; index &lt; arr.length - 1 ; index++) {\n        for(int x = index + 1 ; x &lt; arr.length ; x++) {\n            if(arr[index] &gt; arr[x]) {\n                int temp = arr[index] ;\n                arr[index] = arr[x] ;\n                arr[x] = temp ;\n            }\n        }\n    }\n}\n</code></pre><ul>\n<li>数组高级二分查找<ul>\n<li>每一次都查中间的那个元素，比较大或者小就能减少一半的元素</li><li>数组高级二分查找代码</li></ul>\n</li></ul>\n<pre><code>/**\n * 二分查找\n * @param arr\n * @return\n */\nprivate static int binarySearch2(int[] arr , int value) {\n    // 定义三个变量\n    int minIndex = 0 ;\n    int maxIndex = arr.length - 1 ;\n    while(minIndex &lt;= maxIndex) {\n        int midIndex = (minIndex + maxIndex) &gt;&gt;&gt; 1 ;\n        // 比较\n        if(arr[midIndex] == value) {\n            return midIndex ;\n        }else if(arr[midIndex] &gt; value) {\n            maxIndex = midIndex - 1 ;\n        }else if(arr[midIndex] &lt; value) {\n            minIndex = midIndex + 1 ;\n        }\n    }\n    // 返回\n    return -1;\n}\n</code></pre><h4 id=\"h4-u57FAu672Cu7C7Bu578Bu5305u88C5u7C7B\"><a name=\"基本类型包装类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>基本类型包装类</h4><ul>\n<li>为什么会有基本类型包装类<ul>\n<li>为了对基本数据类型进行更多的操作,更方便的操作,java就针对每一种基本数据类型提供了对应的类类型.</li><li>常用操作:<ul>\n<li>常用的操作之一：用于基本数据类型与字符串之间的转换</li></ul>\n</li></ul>\n</li><li>基本类型和包装类的对应</li></ul>\n<pre><code>    byte           Byte\n    short          Short\n    int            Integer\n    long           Long\n    float          Float\n    double         Double\n    char           Character\n    boolean        Boolean\n</code></pre><h4 id=\"h4-math-\"><a name=\"Math类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Math类</h4><ul>\n<li>Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。</li><li>成员变量</li></ul>\n<pre><code>public static final double E :         自然底数\npublic static final double PI:        圆周率\n</code></pre><ul>\n<li>成员方法</li></ul>\n<pre><code>public static int abs(int a)               取绝对值\npublic static double ceil(double a)        向上取整\npublic static double floor(double a)       向下取整\npublic static int max(int a,int b)         获取最大值\npublic static int min(int a, int b)        获取最小值\npublic static double pow(double a,double b)获取a的b次幂\npublic static double random()              获取随机数  返回带正号的 double 值，该值大于等于 0.0 且小于 1.0。\npublic static int round(float a)           四舍五入\npublic static double sqrt(double a)        获取正平方根\n</code></pre><h4 id=\"h4-random-\"><a name=\"Random类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Random类</h4><ul>\n<li>随机类<ul>\n<li>此类用于产生随机数如果用相同的种子创建两个 Random 实例，则对每个实例进行相同的方法调用序列，它们将生成并返回相同的数字序列</li><li>构造方法<pre><code>public Random()             \n  没有给定种子,使用的是默认的(当前系统的毫秒值)\npublic Random(long seed) \n  给定一个long类型的种子,给定以后每一次生成的随机数是相同的\npublic int nextInt()\npublic int nextInt(int n)\n</code></pre></li></ul>\n</li></ul>\n<h4 id=\"h4-calendar-\"><a name=\"Calendar类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Calendar类</h4><pre><code>  从JDK1.1版本开始，在处理日期和时间时，系统推荐使用Calendar类进行实现(Date的一些方法都过时了)。在设计上，Calendar类的功能要比Date类强大很多，而且在实现方式上也比Date类要复杂一些，下面就介绍一下Calendar类的使用。\n  Calender类是一个抽象类，在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明的，只需要使用getInstance()方法创建即可。\n\n　　1.使用Calendar类代表当前时间\n\n　　Calendar c = Calendar.getInstance();\n         System.out.println(c);  //返回的是一个Calendar对象\n\n　　由于Calendar类是抽象类，且Calendar类的构造方法是protected的，所以无法使用Calendar类的构造方法来创建对象，API中提供了getInstance方法用来创建对象。使用该方法获得的Calendar对象就代表当前的系统时间，由于Calendar类toString实现的没有Date类那么直观，所以直接输出Calendar类的对象意义不大。\n</code></pre><ul>\n<li>获取时间<pre><code>// 使用默认时区和语言环境获得一个日历\n  Calendar cal = Calendar.getInstance();\n  // 赋值时年月日时分秒常用的6个值，注意月份下标从0开始，所以取月份要+1\n  System.out.println(&quot;年:&quot; + cal.get(Calendar.YEAR));\n  System.out.println(&quot;月:&quot; + (cal.get(Calendar.MONTH) + 1));       \n  System.out.println(&quot;日:&quot; + cal.get(Calendar.DAY_OF_MONTH));\n  System.out.println(&quot;时:&quot; + cal.get(Calendar.HOUR_OF_DAY));\n  System.out.println(&quot;分:&quot; + cal.get(Calendar.MINUTE));\n  System.out.println(&quot;秒:&quot; + cal.get(Calendar.SECOND));\n</code></pre>今天是2018年12月16日<br>输出为:<pre><code>  年:2018\n  月:12\n  日:16\n  时:15\n  分:57\n  秒:39\n</code></pre><h3 id=\"h3-simpledateformat\"><a name=\"SimpleDateFormat\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>SimpleDateFormat</h3><pre><code>java中使用SimpleDateFormat类的构造函数\nSimpleDateFormat(String str)构造格式化日期的格式,\n通过format(Date date)方法将指定的日期对象格式化为指定格式的字符串.\n</code></pre>```<br>import java.text.SimpleDateFormat;<br>import java.util.Date;</li></ul>\n<p>public class Main{<br>    public static void main(String[] args){<br>        Date date = new Date();<br>        String strDateFormat = “yyyy-MM-dd HH<img src=\"http://www.emoji-cheat-sheet.com/graphics/emojis/mm.png\" class=\"emoji\" title=\"&#58;mm&#58;\" alt=\"&#58;mm&#58;\" />ss”;<br>        SimpleDateFormat sdf = new SimpleDateFormat(strDateFormat);<br>        System.out.println(sdf.format(date));<br>    }<br>}</p>\n<pre><code>输出结果为:\n</code></pre><pre><code>2018年12月16日16:12:53\n</code></pre><p>```</p>\n<h4 id=\"h4-system-\"><a name=\"System类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>System类</h4><ul>\n<li>系统级类<ul>\n<li>System 类包含一些有用的类字段和方法。它不能被实例化。</li><li>系统级操作</li></ul>\n</li></ul>\n', null, '1', '2019-05-09 00:00:00', '2019-05-09 15:42:25', '0');
INSERT INTO `blog` VALUES ('18', 'java基础(四) 泛型', '<p>首先我们来看一段代码</p>\n<pre><code>    List arrayList = new ArrayList();\n    arrayList.add(&quot;aaaa&quot;);\n    arrayList.add(&quot;bbb&quot;);\n    arrayList.add(100);\n\n    for(int i = 0; i&lt; arrayList.size();i++){\n        String item = (String)arrayList.get(i);\n        Log.d(&quot;泛型测试&quot;,&quot;item = &quot; + item);\n    }\n</code></pre><p>毫无疑问，程序的运行结果会以崩溃结束：</p>\n<pre><code>java.lang.ClassCastException: \n        java.lang.Integer cannot be cast to java.lang.String\n</code></pre><ul>\n<li>定义了一个ArrayList类型的集合,先向其中加入两个字符串类型的值,随后加入一个Integer类型的值.这是完全没有问题的,因为此时List默认的类型为Object类型.<br>ArrayList可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，因此程序崩溃了。为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。</li></ul>\n<h4 id=\"h4-u6CDBu578B\"><a name=\"泛型\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>泛型</h4><p>泛型在java中有很重要的地位，在面向对象编程及各种设计模式中有非常广泛的应用。<br>什么是泛型？为什么要使用泛型？</p>\n<ul>\n<li>泛型,即”参数化类型”. 一提到参数,最熟悉的就是定义方法时有形参,然后调用方法传递实参.那么参数化类型怎么理解呢?<br>顾名思义,就是讲类型由原来具体的类型参数化,类似于方法中的变量参数,此时类型也定义成参数形式(可以称之为类型形参),然后在使用(或调用)是传入具体的类型(类型实参)<br>泛型的本质是为了参数化类型(在不创建新的类型情况下,通过泛型指定的不同类型来控制形参具体限制的类型).<br>也就是说在泛型的使用过程中,操作的数据类型被指定为一个参数,这种参数类型可以用在类,接口和方法中,<br>它们分别称为<strong>泛型类,泛型接口,泛型方法</strong>.</li></ul>\n<h4 id=\"h4-u683Cu5F0F\"><a name=\"格式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>格式</h4><ul>\n<li>泛型格式<ul>\n<li>&lt;数据类型&gt; 这里的数据类型只能是引用数据类型</li><li>&lt;数据类型1 , 数据类型2 , ….&gt;</li></ul>\n</li></ul>\n<h4 id=\"h4-u6CDBu578Bu7684u597Du5904\"><a name=\"泛型的好处\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>泛型的好处</h4><ul>\n<li>把运行时期的问题提前到了编译期间</li><li>避免了强制类型转换</li><li>优化的程序设计</li></ul>\n<h4 id=\"h4-u6CDBu578Bu7684u4F7Fu7528\"><a name=\"泛型的使用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>泛型的使用</h4><ul>\n<li><strong>泛型类: 把泛型定义在类上</strong><ul>\n<li>定义格式: public class 类名&lt;泛型类型1,…&gt;</li><li>注意事项: 泛型类型必须是引用类型</li><li>泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。</li></ul>\n</li></ul>\n<pre><code>    public class Box&lt;T&gt; {\n\n          private T t;\n\n          public void add(T t) {\n            this.t = t;\n          }\n\n          public T get() {\n            return t;\n          }\n\n          public static void main(String[] args) {\n            Box&lt;Integer&gt; integerBox = new Box&lt;Integer&gt;();\n            Box&lt;String&gt; stringBox = new Box&lt;String&gt;();\n\n            integerBox.add(new Integer(10));\n            stringBox.add(new String(&quot;123132&quot;));\n\n            System.out.printf(&quot;整型值为 :%d\\n\\n&quot;, integerBox.get());\n            System.out.printf(&quot;字符串为 :%s\\n&quot;, stringBox.get());\n          }\n    }\n</code></pre><ul>\n<li><strong>泛型方法: 把泛型定义在方法上</strong><ul>\n<li>定义格式: public &lt;泛型类型&gt; 返回类型 方法名(泛型类型 变量名)</li><li>所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的&lt;E&gt;）。<br>每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。<br>类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。<br>泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（像int,double,char的等）。</li></ul>\n</li></ul>\n<pre><code>        public class GenericMethodTest{\n           // 泛型方法 printArray                         \n           public static &lt; E &gt; void printArray( E[] inputArray ){\n              // 输出数组元素            \n                 for ( E element : inputArray ){        \n                    System.out.printf( &quot;%s &quot;, element );\n                 }\n                 System.out.println();\n            }\n\n            public static void main( String args[] ){\n                // 创建不同类型数组： Integer, Double 和 Character\n                Integer[] intArray = { 1, 2, 3, 4, 5 };\n                Double[] doubleArray = { 1.1, 2.2, 3.3, 4.4 };\n                Character[] charArray = { &#39;H&#39;, &#39;E&#39;, &#39;L&#39;, &#39;L&#39;, &#39;O&#39; };\n\n                System.out.println( &quot;整型数组元素为:&quot; );\n                printArray( intArray  ); // 传递一个整型数组\n\n                System.out.println( &quot;\\n双精度型数组元素为:&quot; );\n                printArray( doubleArray ); // 传递一个双精度型数组\n\n                System.out.println( &quot;\\n字符型数组元素为:&quot; );\n                printArray( charArray ); // 传递一个字符型数组\n            } \n        }\n</code></pre><ul>\n<li><p><strong>泛型接口:把泛型定义在接口上</strong></p>\n<ul>\n<li><p>定义格式: public interface 接口名&lt;泛型类型&gt;<br>```<br>  /**</p>\n<ul>\n<li>泛型接口的定义格式:        </li><li><p>修饰符  interface 接口名&lt;数据类型&gt; {}<br>*/<br>public interface Inter&lt;T&gt; {<br> public abstract void show(T t) ;<br>}</p>\n<p>/**</p>\n</li><li>子类是泛型类<br>*/<br>public class InterImpl&lt;E&gt; implements Inter&lt;E&gt; {<br> <a href=\"https://github.com/Override\" title=\"&#64;Override\" class=\"at-link\"><a href=\"https://github.com/Override\" title=\"&#64;Override\" class=\"at-link\"><a href=\"https://github.com/Override\" title=\"&#64;Override\" class=\"at-link\">@Override</a></a></a><br> public void show(E t) {<pre><code> System.out.println(t);\n</code></pre> }<br>}</li></ul>\n</li></ul>\n</li></ul>\n<pre><code>    Inter&lt;String&gt; inter = new InterImpl&lt;String&gt;() ;\n    inter.show(&quot;hello&quot;) ;\n</code></pre><p>```</p>\n<h4 id=\"h4-u6CDBu578Bu9AD8u7EA7u4E4Bu901Au914Du7B26\"><a name=\"泛型高级之通配符\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>泛型高级之通配符</h4><ul>\n<li><p>为什么要使用通配符</p>\n<ul>\n<li>通配符的设计存在一定的场景，例如在使用泛型后，首先声明了一个Animal的类，而后声明了一个继承Animal类的Cat类，显然Cat类是Animal类的子类，但是List却不是List的子类型，而在程序中往往需要表达这样的逻辑关系。为了解决这种类似的场景，在泛型的参数类型的基础上新增了通配符的用法。</li></ul>\n</li><li><p>&lt;? extends T&gt; 上界通配符</p>\n<ul>\n<li>上界通配符顾名思义，&lt;? extends T&gt;表示的是类型的上界【 包含自身】，因此通配的参数化类型可能是T或T的子类。正因为无法确定具体的类型是什么，add方法受限（可以添加null，因为null表示任何类型），但可以从列表中获取元素后赋值给父类型。如上图中的第一个例子，第三个add()操作会受限，原因在于List和List是List&lt;? extends Animal&gt;的子类型。</li></ul>\n</li><li><p>&lt;? super T&gt; 下界通配符</p>\n<ul>\n<li>下界通配符&lt;? super T&gt;表示的是参数化类型是T的超类型（包含自身），层层至上，直至Object，编译器无从判断get()返回的对象的类型是什么，因此get()方法受限。但是可以进行add()方法，add()方法可以添加T类型和T类型的子类型，如第二个例子中首先添加了一个Cat类型对象，然后添加了两个Cat子类类型的对象，这种方法是可行的，但是如果添加一个Animal类型的对象，显然将继承的关系弄反了，是不可行的。</li></ul>\n</li><li><p>&lt;?&gt; 无界通配符</p>\n<ul>\n<li>任意类型，如果没有明确，那么就是Object以及任意的Java类了<br>无界通配符用&lt;?&gt;表示，?代表了任何的一种类型，能代表任何一种类型的只有null（Object本身也算是一种类型，但却不能代表任何一种类型，所以List和List的含义是不同的，前者类型是Object，也就是继承树的最上层，而后者的类型完全是未知的）。</li></ul>\n</li></ul>\n', '首先我们来看一段代码\n```\n	List arrayList = new ArrayList();\n	arrayList.add(\"aaaa\");\n	arrayList.add(\"bbb\");\n	arrayList.add(100);\n\n	for(int i = 0; i< arrayList.size();i++){\n		String item = (String)arrayList.get(i);\n		Log.d(\"泛型测试\",\"item = \" + item);\n	}\n```\n毫无疑问，程序的运行结果会以崩溃结束：\n```\njava.lang.ClassCastException: \n		java.lang.Integer cannot be cast to java.lang.String\n```\n\n* 定义了一个ArrayList类型的集合,先向其中加入两个字符串类型的值,随后加入一个Integer类型的值.这是完全没有问题的,因为此时List默认的类型为Object类型.\nArrayList可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，因此程序崩溃了。为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。\n\n#### 泛型\n泛型在java中有很重要的地位，在面向对象编程及各种设计模式中有非常广泛的应用。\n什么是泛型？为什么要使用泛型？\n* 泛型,即\"参数化类型\". 一提到参数,最熟悉的就是定义方法时有形参,然后调用方法传递实参.那么参数化类型怎么理解呢?                                                                             \n顾名思义,就是讲类型由原来具体的类型参数化,类似于方法中的变量参数,此时类型也定义成参数形式(可以称之为类型形参),然后在使用(或调用)是传入具体的类型(类型实参)\n泛型的本质是为了参数化类型(在不创建新的类型情况下,通过泛型指定的不同类型来控制形参具体限制的类型).\n也就是说在泛型的使用过程中,操作的数据类型被指定为一个参数,这种参数类型可以用在类,接口和方法中,\n它们分别称为**泛型类,泛型接口,泛型方法**.\n\n#### 格式\n- 泛型格式\n	* <数据类型> 这里的数据类型只能是引用数据类型\n	* <数据类型1 , 数据类型2 , ....>\n\n#### 泛型的好处\n- 把运行时期的问题提前到了编译期间\n- 避免了强制类型转换\n- 优化的程序设计\n\n#### 泛型的使用\n- **泛型类: 把泛型定义在类上**\n	* 定义格式: public class 类名<泛型类型1,…>\n	* 注意事项: 泛型类型必须是引用类型\n	* 泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。\n\n```\n	public class Box<T> {\n   \n		  private T t;\n\n		  public void add(T t) {\n			this.t = t;\n		  }\n\n		  public T get() {\n			return t;\n		  }\n\n		  public static void main(String[] args) {\n			Box<Integer> integerBox = new Box<Integer>();\n			Box<String> stringBox = new Box<String>();\n\n			integerBox.add(new Integer(10));\n			stringBox.add(new String(\"123132\"));\n\n			System.out.printf(\"整型值为 :%d\\n\\n\", integerBox.get());\n			System.out.printf(\"字符串为 :%s\\n\", stringBox.get());\n		  }\n	}\n```\n\n- **泛型方法: 把泛型定义在方法上**\n	* 定义格式: public <泛型类型> 返回类型 方法名(泛型类型 变量名)\n	* 所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的<E>）。\n每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。\n类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。\n泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（像int,double,char的等）。\n\n```\n		public class GenericMethodTest{\n		   // 泛型方法 printArray                         \n		   public static < E > void printArray( E[] inputArray ){\n			  // 输出数组元素            \n				 for ( E element : inputArray ){        \n					System.out.printf( \"%s \", element );\n				 }\n				 System.out.println();\n			}\n\n			public static void main( String args[] ){\n				// 创建不同类型数组： Integer, Double 和 Character\n				Integer[] intArray = { 1, 2, 3, 4, 5 };\n				Double[] doubleArray = { 1.1, 2.2, 3.3, 4.4 };\n				Character[] charArray = { \'H\', \'E\', \'L\', \'L\', \'O\' };\n\n				System.out.println( \"整型数组元素为:\" );\n				printArray( intArray  ); // 传递一个整型数组\n\n				System.out.println( \"\\n双精度型数组元素为:\" );\n				printArray( doubleArray ); // 传递一个双精度型数组\n\n				System.out.println( \"\\n字符型数组元素为:\" );\n				printArray( charArray ); // 传递一个字符型数组\n			} \n		}\n```\n\n- **泛型接口:把泛型定义在接口上**\n	* 定义格式: public interface 接口名<泛型类型>\n```\n		/**\n		 * 泛型接口的定义格式:        \n		 * 修饰符  interface 接口名<数据类型> {}\n		 */\n		public interface Inter<T> {\n			public abstract void show(T t) ;\n		}\n\n		/**\n		 * 子类是泛型类\n		 */\n		public class InterImpl<E> implements Inter<E> {\n			@Override\n			public void show(E t) {\n				System.out.println(t);\n			}\n		}\n\n\n		Inter<String> inter = new InterImpl<String>() ;\n		inter.show(\"hello\") ;\n```\n\n#### 泛型高级之通配符\n- 为什么要使用通配符\n	* 通配符的设计存在一定的场景，例如在使用泛型后，首先声明了一个Animal的类，而后声明了一个继承Animal类的Cat类，显然Cat类是Animal类的子类，但是List却不是List的子类型，而在程序中往往需要表达这样的逻辑关系。为了解决这种类似的场景，在泛型的参数类型的基础上新增了通配符的用法。\n\n- <? extends T> 上界通配符\n\n	* 上界通配符顾名思义，<? extends T>表示的是类型的上界【 包含自身】，因此通配的参数化类型可能是T或T的子类。正因为无法确定具体的类型是什么，add方法受限（可以添加null，因为null表示任何类型），但可以从列表中获取元素后赋值给父类型。如上图中的第一个例子，第三个add()操作会受限，原因在于List和List是List<? extends Animal>的子类型。\n	\n-  <? super T> 下界通配符\n\n	*  下界通配符<? super T>表示的是参数化类型是T的超类型（包含自身），层层至上，直至Object，编译器无从判断get()返回的对象的类型是什么，因此get()方法受限。但是可以进行add()方法，add()方法可以添加T类型和T类型的子类型，如第二个例子中首先添加了一个Cat类型对象，然后添加了两个Cat子类类型的对象，这种方法是可行的，但是如果添加一个Animal类型的对象，显然将继承的关系弄反了，是不可行的。\n	\n- <?> 无界通配符\n\n	* 任意类型，如果没有明确，那么就是Object以及任意的Java类了\n无界通配符用<?>表示，?代表了任何的一种类型，能代表任何一种类型的只有null（Object本身也算是一种类型，但却不能代表任何一种类型，所以List和List的含义是不同的，前者类型是Object，也就是继承树的最上层，而后者的类型完全是未知的）。', '1', '2019-05-09 14:23:55', '2019-05-09 14:23:55', '0');
INSERT INTO `blog` VALUES ('19', 'java基础(五) 面向对象', '<h4 id=\"h4-u9762u5411u5BF9u8C61u7684u601Du60F3\"><a name=\"面向对象的思想\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>面向对象的思想</h4><ul>\n<li><p>在理解面向对象思想,我们可以先来看看什么是面向过程?</p>\n<ul>\n<li>面向过程思想概述<br>我们来回想一下，这几天我们完成一个需求的步骤：首先是搞清楚我们要做什么，然后在分析怎么做，最后我们再代码体现。<br>一步一步去实现，而具体的每一步都需要我们去实现和操作。这些步骤相互调用和协作，完成我们的需求。<br>在上面的每一个具体步骤中我们都是参与者，并且需要面对具体的每一个步骤和过程，这就是面向过程最直接的体现。<br>那么什么是面向过程开发呢? 面向过程开发，其实就是面向着具体的每一个步骤和过程，把每一个步骤和过程完成，然后由这些功能方法相互调用，完成需求。<br>面向过程的代表语言：C语言</li></ul>\n</li><li><p>然后我们再来了解面向对象</p>\n<ul>\n<li>面向对象思想概述<br>当需求单一，或者简单时，我们一步一步去操作没问题，并且效率也挺高。<br>可随着需求的更改，功能的增多，发现需要面对每一个步骤很麻烦了。这时就开始思索，<br>能不能把这些步骤和功能在进行封装，封装时根据不同的功能，进行不同的封装，功能类似的封装在一起。<br>这样结构就清晰了很多。用的时候，找到对应的类就可以了。这就是面向对象的思想。</li><li>面向对象思想特点<br>  是一种更符合我们思想习惯的思想<br>可以将复杂的事情简单化<br>将我们从执行者变成了指挥者<br>  角色发生了转换</li></ul>\n</li></ul>\n<h4 id=\"h4-u7C7Bu4E0Eu5BF9u8C61u53CAu5176u5E94u7528\"><a name=\"类与对象及其应用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>类与对象及其应用</h4><ul>\n<li>属性： 该事物的描述信息    </li><li>行为： 该事物能够做什么    </li></ul>\n<p>现实事物  | 类|<br>|——————- | ——————-|<br>属性  | 成员变量|<br>行为|成员方法|</p>\n<ul>\n<li>类： 是一组相同属性和行为的集合。这是一个抽象的概念</li><li>对象：是该类事物的具体表现形式，具体存在的个体。<br>  例子<pre><code>  学生： 类\n  班长： 对象\n</code></pre></li></ul>\n<h4 id=\"h4-u6210u5458u53D8u91CFu548Cu5C40u90E8u53D8u91CFu7684u533Au522B\"><a name=\"成员变量和局部变量的区别\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>成员变量和局部变量的区别</h4><p>成员变量就是方法外部,类的内部定义的变量;<br>局部变量就是方法或语句块内部定义的变量.局部变量必须初始化.</p>\n<ul>\n<li>在类中的位置不同<br>成员变量：在类中方法外<br>局部变量：在方法定义中或者方法声明上</li><li>在内存中的位置不同<br>成员变量：在堆内存<br>局部变量：在栈内存</li><li>生命周期不同<br>成员变量：随着对象的创建而存在，随着对象的消失而消失<br>局部变量：随着方法的调用而存在，随着方法的调用完毕而消失</li><li>初始化值不同<br>成员变量：有默认初始化值<br>局部变量：没有默认初始化值，必须定义，赋值，然后才能使用。<br>注意事项：: 局部变量名称可以和成员变量名称一样，在方法中使用的时候，采用的是就近原则</li></ul>\n<h4 id=\"h4-u533Fu540Du5BF9u8C61\"><a name=\"匿名对象\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>匿名对象</h4><ul>\n<li>什么是匿名对象<br>就是没有名字的对象</li><li>匿名对象应用场景<ul>\n<li>调用方法，仅仅只调用一次的时候。</li><li>匿名对象可以作为实际参数传递</li></ul>\n</li></ul>\n<h4 id=\"h4--\"><a name=\"方法的重写,方法重载\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>方法的重写,方法重载</h4><h5 id=\"h5-u65B9u6CD5u91CDu5199\"><a name=\"方法重写\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>方法重写</h5><ul>\n<li>方法重写是子类对父类的允许访问方法的实现过程进行重新编写,返回值和形参都不变.<br>即外壳不变,核心改变<ul>\n<li>方法重写好处在于子类可以根据需求定义特定自己的行为,也就是说子类可以根据需求实现父类的方法</li><li>注意: 重写的方法不能抛出新的异常或者比被重写方法申明更加宽泛的异常</li><li>当子类中应用父类被重写的方法时,要使用super关键字<br>super表示对父类对象的引用。使用了super显示的调用父类的某个构造方法后，<br>那么在执行的时候就寻找super()对应的构造方法，而不再寻找父类的不带参数的构造方法。</li><li>super必须作为构造方法的第一条执行语句。<br>在写类的时候，一定要写默认无参的构造方法，如果一个构造方法的第一句既不是this(),<br>也不是super()时，那么就会在这里隐含的调用他的父类的无参的构造方法，即隐含的调用super()。</li></ul>\n</li><li>方法重写应用<br>当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法。<br>这样，即沿袭了父类的功能，又定义了子类特有的内容。<br>```<br>/<em>*\n</em>重写<br>*/<br>class Animal{<br>  public void move(){<pre><code>  System.out.println(&quot;动物可以移动&quot;);\n</code></pre>  }</li></ul>\n<p>}<br>class Dog extends Animal{<br>    public void move (){<br>        super.move(); //应用super类方法<br>        System.out.println(“狗也可以跑和走”);<br>    }<br>}<br>public class TestDog{<br>    public static void main(String args[]){<br>        //Animal a = new Animal();<br>        Animal b = new Dog();</p>\n<pre><code>    //a.move();// 执行 Animal 类的方法\n\n    b.move();//执行 Dog 类的方法\n}\n</code></pre><p>}</p>\n<pre><code>##### 方法重载\n- 重载: overload是在一个类里面,方法名字相同,而参数不同,返回类型可以相同也可以不同\n    * 每一个重载的方法(或者构造函数)都必须有一个独一无二的参数型列表\n    * 最常用的就是构造器重载\n    * 被重载的方法必须改变参数列表(参数的个数或类型不一样)\n- 方法重载原则\n方法名相同；方法的参数类型不同，或者参数个数不同；与方法的参数名，返回类型和修饰符无关\n</code></pre><p>/*</p>\n<ul>\n<li>重载<br>*/</li></ul>\n<p>public class OverLoading{<br>    public int test(){<br>        System.out.println(“test1”);<br>        return 1;<br>    }<br>    //一个参数<br>    public void test(int a){<br>        System.out.println(“test2”);<br>    }</p>\n<pre><code>//以下两个参数顺序不同\npublic String test(int a,String s){\n    System.out.println(&quot;test3&quot;);\n    return &quot;return test3&quot;;\n}\n\n//以下两个参数顺序不同\npublic String test(String s,int a){\n    System.out.println(&quot;test4&quot;);\n    return &quot;return test4&quot;;\n}\n\n\npublic static void main(String args []){\n    OverLoading o = new OverLoading();\n    System.out.println(o.test());\n    o.test(1);\n    System.out.println(o.test(1,&quot;test3&quot;));\n    System.out.println(o.test(&quot;test4&quot;,1));\n}\n</code></pre><p>}<br>```</p>\n', '#### 面向对象的思想\n- 在理解面向对象思想,我们可以先来看看什么是面向过程?\n	* 面向过程思想概述\n  我们来回想一下，这几天我们完成一个需求的步骤：首先是搞清楚我们要做什么，然后在分析怎么做，最后我们再代码体现。\n    一步一步去实现，而具体的每一步都需要我们去实现和操作。这些步骤相互调用和协作，完成我们的需求。\n    在上面的每一个具体步骤中我们都是参与者，并且需要面对具体的每一个步骤和过程，这就是面向过程最直接的体现。\n    那么什么是面向过程开发呢? 面向过程开发，其实就是面向着具体的每一个步骤和过程，把每一个步骤和过程完成，然后由这些功能方法相互调用，完成需求。\n    面向过程的代表语言：C语言\n\n- 然后我们再来了解面向对象\n	*  面向对象思想概述\n	当需求单一，或者简单时，我们一步一步去操作没问题，并且效率也挺高。\n    可随着需求的更改，功能的增多，发现需要面对每一个步骤很麻烦了。这时就开始思索，\n    能不能把这些步骤和功能在进行封装，封装时根据不同的功能，进行不同的封装，功能类似的封装在一起。\n    这样结构就清晰了很多。用的时候，找到对应的类就可以了。这就是面向对象的思想。\n	* 面向对象思想特点\n		是一种更符合我们思想习惯的思想\n    可以将复杂的事情简单化\n    将我们从执行者变成了指挥者\n        角色发生了转换\n\n#### 类与对象及其应用\n- 属性： 该事物的描述信息	\n- 行为： 该事物能够做什么	\n\n\n现实事物  | 类|\n|------------- | -------------|\n属性  | 成员变量|\n行为|成员方法|\n\n	\n- 类： 是一组相同属性和行为的集合。这是一个抽象的概念\n- 对象：是该类事物的具体表现形式，具体存在的个体。\n	例子\n		学生： 类\n		班长： 对象\n		\n#### 成员变量和局部变量的区别\n成员变量就是方法外部,类的内部定义的变量;\n局部变量就是方法或语句块内部定义的变量.局部变量必须初始化.\n- 在类中的位置不同\n成员变量：在类中方法外\n局部变量：在方法定义中或者方法声明上\n- 在内存中的位置不同\n成员变量：在堆内存\n局部变量：在栈内存\n- 生命周期不同\n成员变量：随着对象的创建而存在，随着对象的消失而消失\n局部变量：随着方法的调用而存在，随着方法的调用完毕而消失\n- 初始化值不同\n成员变量：有默认初始化值\n局部变量：没有默认初始化值，必须定义，赋值，然后才能使用。\n注意事项：: 局部变量名称可以和成员变量名称一样，在方法中使用的时候，采用的是就近原则\n\n#### 匿名对象\n- 什么是匿名对象\n就是没有名字的对象\n-  匿名对象应用场景\n	* 调用方法，仅仅只调用一次的时候。\n	* 匿名对象可以作为实际参数传递\n\n#### 方法的重写,方法重载\n##### 方法重写\n- 方法重写是子类对父类的允许访问方法的实现过程进行重新编写,返回值和形参都不变.\n即外壳不变,核心改变\n	* 方法重写好处在于子类可以根据需求定义特定自己的行为,也就是说子类可以根据需求实现父类的方法\n	* 注意: 重写的方法不能抛出新的异常或者比被重写方法申明更加宽泛的异常\n	* 当子类中应用父类被重写的方法时,要使用super关键字\nsuper表示对父类对象的引用。使用了super显示的调用父类的某个构造方法后，\n那么在执行的时候就寻找super()对应的构造方法，而不再寻找父类的不带参数的构造方法。\n	* super必须作为构造方法的第一条执行语句。\n在写类的时候，一定要写默认无参的构造方法，如果一个构造方法的第一句既不是this(),\n也不是super()时，那么就会在这里隐含的调用他的父类的无参的构造方法，即隐含的调用super()。\n- 方法重写应用\n当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法。\n这样，即沿袭了父类的功能，又定义了子类特有的内容。\n```\n/**\n*重写\n*/\nclass Animal{\n	public void move(){\n		System.out.println(\"动物可以移动\");\n	}\n	\n}\nclass Dog extends Animal{\n	public void move (){\n		super.move(); //应用super类方法\n		System.out.println(\"狗也可以跑和走\");\n	}\n}\npublic class TestDog{\n	public static void main(String args[]){\n		//Animal a = new Animal();\n		Animal b = new Dog();\n		\n		//a.move();// 执行 Animal 类的方法\n \n        b.move();//执行 Dog 类的方法\n	}\n}\n```\n##### 方法重载\n- 重载: overload是在一个类里面,方法名字相同,而参数不同,返回类型可以相同也可以不同\n	* 每一个重载的方法(或者构造函数)都必须有一个独一无二的参数型列表\n	* 最常用的就是构造器重载\n	* 被重载的方法必须改变参数列表(参数的个数或类型不一样)\n- 方法重载原则\n方法名相同；方法的参数类型不同，或者参数个数不同；与方法的参数名，返回类型和修饰符无关\n\n```\n\n/*\n* 重载\n*/\n\npublic class OverLoading{\n	public int test(){\n		System.out.println(\"test1\");\n		return 1;\n	}\n	//一个参数\n	public void test(int a){\n		System.out.println(\"test2\");\n	}\n	\n	//以下两个参数顺序不同\n	public String test(int a,String s){\n		System.out.println(\"test3\");\n		return \"return test3\";\n	}\n	\n	//以下两个参数顺序不同\n	public String test(String s,int a){\n		System.out.println(\"test4\");\n		return \"return test4\";\n	}\n	\n	\n	public static void main(String args []){\n		OverLoading o = new OverLoading();\n		System.out.println(o.test());\n		o.test(1);\n		System.out.println(o.test(1,\"test3\"));\n        System.out.println(o.test(\"test4\",1));\n	}\n\n}\n```', '1', '2019-05-09 14:24:29', '2019-05-09 14:24:29', '0');
INSERT INTO `blog` VALUES ('20', 'java基础(六) java封装继承多态', '<h4 id=\"h4-u9762u5411u5BF9u8C61u7684u7279u5F81\"><a name=\"面向对象的特征\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>面向对象的特征</h4><ul>\n<li>有三个特征<ul>\n<li>封装</li><li>继承</li><li>多态<h5 id=\"h5-u5C01u88C5\"><a name=\"封装\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>封装</h5>是指隐藏对象的属性和实现细节，仅对外提供公共访问方式</li></ul>\n</li><li>原则: <pre><code> 将不需要的对外提供的内容隐藏起来,把属性隐藏，提供公共的对外访问方法\n</code></pre></li><li><p>封装的优点</p>\n<pre><code>  1. 良好的封装能够减少耦合。\n  2. 类内部的结构可以自由修改。\n  3. 可以对成员变量进行更精确的控制。\n  4. 隐藏信息，实现细节。\n</code></pre><ul>\n<li>以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。</li><li><p>注意到gender属性使用int数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。</p>\n<pre><code>public class Person {\n\nprivate String name;\nprivate int gender;\nprivate int age;\n\npublic String getName() {\n  return name;\n}\n\npublic void setName(String name){\n  this.name = name;\n}\n\npublic String getGender() {\n  return gender == 0 ? &quot;man&quot; : &quot;woman&quot;;\n}\n\npublic void work() {\n  if (18 &lt;= age &amp;&amp; age &lt;= 50) {\n      System.out.println(name + &quot; is working very hard!&quot;);\n  } else {\n      System.out.println(name + &quot; can&#39;t work any more!&quot;);\n  }\n}\n}\n</code></pre></li></ul>\n</li><li><p>构造方法<br>每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。<br>在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。</p>\n<ul>\n<li>构造方法概述和作用<br>  给对象中的成员进行初始化</li><li>构造方法格式特点<br>  方法名与类名相同；没有返回值类型，连void都没有</li><li>构造方法注意事项<br>如果我们没有给出构造方法，系统将自动提供一个无参构造方法。<br>如果我们给出了构造方法，系统将不再提供默认的无参构造方法。</li><li><p>注意：这个时候，如果我们还想使用无参构造方法，就必须自己给出。建议永远自己给出无参构造方法</p>\n<pre><code>public class Puppy{\npublic Puppy(){\n  //无参构造方法\n}\n\npublic Puppy(String name){\n  // 这个构造器仅有一个参数：name\n}\n}\n</code></pre></li></ul>\n</li><li>paivate关键字<ul>\n<li>private关键字特点<br>  是一个权限修饰符<br>  可以修饰成员变量和成员方法<br>  被其修饰的成员只能在本类中被访问<br>  private最常见的应用<br>  把成员变量用private修饰，提供对应的getXxx()和setXxx()方法</li></ul>\n</li><li>this关键字<ul>\n<li>为什么要有this<br>  当我们的局部变量和成员变量相同的时候,如果我们不使用this关键字,那么会导致一个问题:就是局部变量隐藏了成员变量的问题</li><li>this关键字特点<br>  是当前类的对象引用<br>  简单的记，它就代表当前类的一个对象。谁调用这个方法,那么该方法的内部的this就代表谁</li><li>this的应用场景<br>  解决局部变量隐藏成员变量</li></ul>\n</li></ul>\n<h4 id=\"h4-u7EE7u627F\"><a name=\"继承\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>继承</h4><p>继承是子类继承父类的特征和行为,使得子类对象(实例)具有父类的实例域和方法,或子类从父类继承方法,使子类具有父类的行为.</p>\n<ul>\n<li>继承的特性<ul>\n<li>子类拥有父类非private的属性，方法。</li><li>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li><li>Java的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如A类继承B类，B类继承C类，所以按照关系就是C类是B类的父类，B类是A类的父类，这是java继承区别于C++继承的一个特性。</li><li>提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。</li></ul>\n</li><li>继承的格式<ul>\n<li>在 Java 中通过 extends 关键字可以申明一个类是从另外一个类继承而来的<br>```<br>class 父类 {<br>}</li></ul>\n</li></ul>\n<p>class 子类 extends 父类 {<br>}</p>\n<pre><code>```\n/父类 动物\nclass Animal{\n    private String name;\n    private int id;\n\n    public Animal(String myName, int myId){\n        name = myName;\n        id = myId;\n    }\n\n    public void eat(){\n        System.out.println(name+&quot;正在吃&quot;);\n    }\n\n    public void sleep(){\n        System.out.println(name+&quot;正在谁&quot;);\n    }\n\n    //介绍 introduction\n    public void introduction(){\n        System.out.println(&quot;我是&quot;+  id  +&quot;的&quot;+name);\n    }\n}\n\n//子类 企鹅\nclass Penguin extends Animal{\n    public Penguin(String myName, int myId){\n        super(myName,myId);\n    }\n}\n\n//子类 老鼠\nclass Mouse extends Animal{\n    public Mouse(String myName,int myId){\n        super(myName,myId);\n    }\n}\n\npublic class AnimalDemo{\n    public AnimalDemo(){\n\n    }\n\n    public static void main(String [] args){\n        Penguin p = new Penguin(&quot;企鹅&quot;,1);\n        p.eat();\n        p.sleep();\n        p.introduction();\n\n        Mouse m = new Mouse(&quot;老鼠&quot;,2);\n        m.eat();\n        m.sleep();\n        m.introduction();\n    }\n}\n</code></pre><ul>\n<li>继承类型<br>需要注意的是 Java 不支持多继承，但支持多重继承。<br><img src=\"./images/types_of_inheritance_1.png\" alt=\"enter description here\"></li><li><p>继承关键字<br>继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 java.lang 包中，所以不需要 import）祖先类。</p>\n</li><li><p>extends关键字<br>在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。<br>```<br>public class Animal {<br>  private String name;<br>  private int id;<br>  public Animal(String myName, String myid) { </p>\n<pre><code>  //初始化属性值\n</code></pre><p>  }<br>  public void eat() {  //吃东西方法的具体实现  }<br>  public void sleep() { //睡觉方法的具体实现  }<br>} </p>\n</li></ul>\n<p>public class Penguin  extends  Animal{<br>}</p>\n<pre><code>\n#### 多态\n- 多态: 多态是同一个行为具有不同表现的形式或形态的能力\n        多态就是一个接口,使用不同实例而执行不同操作\n        多态是对象多种表现形式的体现    \n- 多态的优点\n        1.消除类型之间的耦合关系\n        2.可替换性\n        3.可扩充性\n        4.接口器\n        5.灵活性\n        6.简化性\n- 缺点\n            不能使用子类的特有的功能\n            解决: 把父类中的引用强制转换成子类的引用(向下转型)\n                    Fu f = new Zi();\n                    Zi z = (zi)f;  //向下转型    \n- 对象之间的转型\n            向上转型\n                Fu f = new Zi();\n            向下转型\n                Zi z = (zi)f;  //要求改f必须是能够转换成Zi的        \n- 多态存在的三个必要条件\n        继承\n        重写\n        父类引用子类对象\n- 多态的实现方式        \n    方式一：重写\n    方式二：接口\n    方式三：抽象类和抽象方法\n</code></pre><p>/<em>*<br>多态\n</em><br>/<br>public class Test{<br>    public static void main(String args []){<br>        show(new Cat()); //以Cat对象调用show方法<br>        show(new Dog()); //以Dog对象调用show方法</p>\n<pre><code>    Animal a = new Cat(); //向上转型\n    a.eat();    //调用的事Cat的eat方法\n    Cat c = (Cat)a;  //向下转型\n    c.work();   //调用的是Cat的work方法\n}\n\npublic static void show(Animal a){\n    a.eat();\n    //类型判断\n    if( a instanceof Cat){//猫做的事\n        Cat c = (Cat)a;\n        c.work();\n    }else if(a instanceof Dog){//狗做的事\n        Dog c = (Dog)a;\n        c.work();\n    }\n}\n</code></pre><p>}</p>\n<p>abstract class Animal{<br>    abstract void eat();<br>}</p>\n<p>class Cat extends Animal{<br>    public void eat(){<br>        System.out.println(“吃鱼”);<br>    }</p>\n<pre><code>public void work(){\n    System.out.println(&quot;抓老鼠&quot;);\n}\n</code></pre><p>}</p>\n<p>class Dog extends Animal{<br>    public void eat(){<br>        System.out.println(“吃骨头”);<br>    }</p>\n<pre><code>public void work(){\n    System.out.println(&quot;看家&quot;);\n}\n</code></pre><p>}<br>```</p>\n<ul>\n<li><p>多态的成员访问特点</p>\n<pre><code>  访问成员变量\n      编译看左边,运行也看左边\n  构造方法\n      创建子类对象的时候,访问父类的构造方法,对父类的数据进行初始化\n  成员方法\n      编译看左边,运行看右边\n  静态方法\n      编译看左边,运行看左边\n      (静态方法和类有关,算不上重写,所以,访问还是看左边)\n  由于成员方法存在方法重写,所以运行时看右边\n</code></pre></li><li><p>多态报错<br>ClassCastException 类型转换异常, 一般在多态的向下转型中出现</p>\n</li></ul>\n', '#### 面向对象的特征\n- 有三个特征\n	* 封装\n	* 继承\n	* 多态\n##### 封装\n是指隐藏对象的属性和实现细节，仅对外提供公共访问方式\n-  原则: \n		将不需要的对外提供的内容隐藏起来,把属性隐藏，提供公共的对外访问方法\n- 封装的优点\n		1. 良好的封装能够减少耦合。\n		2. 类内部的结构可以自由修改。\n		3. 可以对成员变量进行更精确的控制。\n		4. 隐藏信息，实现细节。\n	\n	* 以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。\n	* 注意到gender属性使用int数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。\n```\npublic class Person {\n\n    private String name;\n    private int gender;\n    private int age;\n\n    public String getName() {\n        return name;\n    }\n	\n    public void setName(String name){\n		this.name = name;\n	}\n	\n    public String getGender() {\n        return gender == 0 ? \"man\" : \"woman\";\n    }\n\n    public void work() {\n        if (18 <= age && age <= 50) {\n            System.out.println(name + \" is working very hard!\");\n        } else {\n            System.out.println(name + \" can\'t work any more!\");\n        }\n    }\n}\n```\n- 构造方法\n每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。\n在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。\n	* 构造方法概述和作用\n		给对象中的成员进行初始化\n	* 构造方法格式特点\n		方法名与类名相同；没有返回值类型，连void都没有\n	* 构造方法注意事项\n如果我们没有给出构造方法，系统将自动提供一个无参构造方法。\n如果我们给出了构造方法，系统将不再提供默认的无参构造方法。\n	* 注意：这个时候，如果我们还想使用无参构造方法，就必须自己给出。建议永远自己给出无参构造方法\n```\npublic class Puppy{\n    public Puppy(){\n		//无参构造方法\n    }\n \n    public Puppy(String name){\n        // 这个构造器仅有一个参数：name\n    }\n}\n```\n- paivate关键字\n	* private关键字特点\n		是一个权限修饰符\n		可以修饰成员变量和成员方法\n		被其修饰的成员只能在本类中被访问\n		private最常见的应用\n		把成员变量用private修饰，提供对应的getXxx()和setXxx()方法\n- this关键字\n	* 为什么要有this\n		当我们的局部变量和成员变量相同的时候,如果我们不使用this关键字,那么会导致一个问题:就是局部变量隐藏了成员变量的问题\n	* this关键字特点\n		是当前类的对象引用\n		简单的记，它就代表当前类的一个对象。谁调用这个方法,那么该方法的内部的this就代表谁\n	* this的应用场景\n		解决局部变量隐藏成员变量\n		\n#### 继承\n继承是子类继承父类的特征和行为,使得子类对象(实例)具有父类的实例域和方法,或子类从父类继承方法,使子类具有父类的行为.\n- 继承的特性\n	* 子类拥有父类非private的属性，方法。\n	* 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。\n	* 子类可以用自己的方式实现父类的方法。\n	* Java的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如A类继承B类，B类继承C类，所以按照关系就是C类是B类的父类，B类是A类的父类，这是java继承区别于C++继承的一个特性。\n	* 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。\n- 继承的格式\n	* 在 Java 中通过 extends 关键字可以申明一个类是从另外一个类继承而来的\n```\nclass 父类 {\n}\n \nclass 子类 extends 父类 {\n}\n```\n```\n/父类 动物\nclass Animal{\n	private String name;\n	private int id;\n	\n	public Animal(String myName, int myId){\n		name = myName;\n		id = myId;\n	}\n	\n	public void eat(){\n		System.out.println(name+\"正在吃\");\n	}\n	\n	public void sleep(){\n		System.out.println(name+\"正在谁\");\n	}\n	\n	//介绍 introduction\n	public void introduction(){\n		System.out.println(\"我是\"+  id  +\"的\"+name);\n	}\n}\n\n//子类 企鹅\nclass Penguin extends Animal{\n	public Penguin(String myName, int myId){\n		super(myName,myId);\n	}\n}\n\n//子类 老鼠\nclass Mouse extends Animal{\n	public Mouse(String myName,int myId){\n		super(myName,myId);\n	}\n}\n\npublic class AnimalDemo{\n	public AnimalDemo(){\n		\n	}\n	\n	public static void main(String [] args){\n		Penguin p = new Penguin(\"企鹅\",1);\n		p.eat();\n		p.sleep();\n		p.introduction();\n		\n		Mouse m = new Mouse(\"老鼠\",2);\n		m.eat();\n		m.sleep();\n		m.introduction();\n	}\n}\n```\n- 继承类型\n需要注意的是 Java 不支持多继承，但支持多重继承。\n![enter description here](./images/types_of_inheritance_1.png)\n- 继承关键字\n继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 java.lang 包中，所以不需要 import）祖先类。\n\n- extends关键字\n在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。\n```\npublic class Animal { \n    private String name;   \n    private int id; \n    public Animal(String myName, String myid) { \n        //初始化属性值\n    } \n    public void eat() {  //吃东西方法的具体实现  } \n    public void sleep() { //睡觉方法的具体实现  } \n} \n \npublic class Penguin  extends  Animal{ \n}\n```\n\n#### 多态\n- 多态: 多态是同一个行为具有不同表现的形式或形态的能力\n		多态就是一个接口,使用不同实例而执行不同操作\n		多态是对象多种表现形式的体现	\n- 多态的优点\n		1.消除类型之间的耦合关系\n		2.可替换性\n		3.可扩充性\n		4.接口器\n		5.灵活性\n		6.简化性\n- 缺点\n			不能使用子类的特有的功能\n			解决: 把父类中的引用强制转换成子类的引用(向下转型)\n					Fu f = new Zi();\n					Zi z = (zi)f;  //向下转型	\n- 对象之间的转型\n			向上转型\n				Fu f = new Zi();\n			向下转型\n				Zi z = (zi)f;  //要求改f必须是能够转换成Zi的		\n- 多态存在的三个必要条件\n		继承\n		重写\n		父类引用子类对象\n- 多态的实现方式		\n    方式一：重写\n	方式二：接口\n	方式三：抽象类和抽象方法\n```\n/**\n多态\n*\n/\npublic class Test{\n	public static void main(String args []){\n		show(new Cat()); //以Cat对象调用show方法\n		show(new Dog()); //以Dog对象调用show方法\n		\n		Animal a = new Cat(); //向上转型\n		a.eat();	//调用的事Cat的eat方法\n		Cat c = (Cat)a;  //向下转型\n		c.work();   //调用的是Cat的work方法\n	}\n	\n	public static void show(Animal a){\n		a.eat();\n		//类型判断\n		if( a instanceof Cat){//猫做的事\n			Cat c = (Cat)a;\n			c.work();\n		}else if(a instanceof Dog){//狗做的事\n			Dog c = (Dog)a;\n			c.work();\n		}\n	}\n}\n\nabstract class Animal{\n	abstract void eat();\n}\n\nclass Cat extends Animal{\n	public void eat(){\n		System.out.println(\"吃鱼\");\n	}\n	\n	public void work(){\n		System.out.println(\"抓老鼠\");\n	}\n}\n\nclass Dog extends Animal{\n	public void eat(){\n		System.out.println(\"吃骨头\");\n	}\n	\n	public void work(){\n		System.out.println(\"看家\");\n	}\n}\n```\n- 多态的成员访问特点\n		访问成员变量\n			编译看左边,运行也看左边\n		构造方法\n			创建子类对象的时候,访问父类的构造方法,对父类的数据进行初始化\n		成员方法\n			编译看左边,运行看右边\n		静态方法\n			编译看左边,运行看左边\n			(静态方法和类有关,算不上重写,所以,访问还是看左边)\n		由于成员方法存在方法重写,所以运行时看右边\n		\n- 多态报错		\nClassCastException 类型转换异常, 一般在多态的向下转型中出现\n\n', '1', '2019-05-09 14:25:00', '2019-05-09 14:25:00', '0');
INSERT INTO `blog` VALUES ('21', 'java基础(七) 类,对象与接口', '<h4 id=\"h4-u7C7Bu7684u6982u5FF5\"><a name=\"类的概念\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>类的概念</h4><h5 id=\"h5-u7C7B\"><a name=\"类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>类</h5><ul>\n<li>一个类可以包含以下类型变量：<ul>\n<li>局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。<pre><code>  变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。\n</code></pre></li><li>成员变量：成员变量是定义在类中，方法体之外的变量。<pre><code>  这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。\n</code></pre></li><li>类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。</li><li>每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。<br>在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法</li></ul>\n</li></ul>\n<p>&lt;!--more--&gt;\n</p>\n<h5 id=\"h5-u62BDu8C61u7C7B\"><a name=\"抽象类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>抽象类</h5><ul>\n<li>抽象类和抽象方法都使用 abstract 关键字进行声明。抽象类一般会包含抽象方法，抽象方法一定位于抽象类中。</li><li><p>抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。<br>```<br>public abstract class AbstractClassExample {</p>\n<p>  protected int x;<br>  private int y;</p>\n<p>  public abstract void func1();</p>\n<p>  public void func2() {</p>\n<pre><code>  System.out.println(&quot;func2&quot;);\n</code></pre><p>  }<br>}</p>\n</li></ul>\n<p>public class AbstractExtendClassExample extends AbstractClassExample {<br>    <a href=\"https://github.com/Override\" title=\"&#64;Override\" class=\"at-link\">@Override</a><br>    public void func1() {<br>        System.out.println(“func1”);<br>    }<br>}</p>\n<pre><code>\n#### 对象\n* 创建对象\n对象是根据类创建的。在Java中，使用关键字new来创建一个新的对象。创建对象需要以下三步：\n* 声明：声明一个对象，包括对象名称和对象类型。\n* 实例化：使用关键字new来创建一个对象。\n* 初始化：使用new创建对象时，会调用构造方法初始化对象。\n\n#### 接口\n- 接口: java编程语言中的抽象类型,是抽象方法的集合,接口通常以interface来声明.\n    * 一个类通过继承的接口的方式,从而继承接口的抽象方法.\n    * 类实现接口通常用implements表示\n        * 格式: class 类名 implements 接口名{}\n    * 接口不能实例化,需要用多态的方式去实现,接口子类重写\n    * 接口的子类\n        * 可以是抽象类,但是意义不大\n        * 可以是具体类,要重写接口中的所有的抽象方法(推荐)\n- 类实现接口\n        当类实现接口时,类要实现接口中所有的方法,否者类必须声明为抽象类,\n        类使用implements关键字实现接口.在类声明中,implement声明放在class后面\n</code></pre><p>//接口</p>\n<p>interface Animal{<br>    public void eat();</p>\n<pre><code>public void travel();\n</code></pre><p>}</p>\n<p>public class MammalInt implements Animal{<br>    public void eat(){<br>        System.out.println(“MammalInt eat”);<br>    }</p>\n<pre><code>public void travel(){\n    System.out.println(&quot;MammalInt travel&quot;);\n}\n\npublic int onOfLegs(){\n    return 0;\n}\n\npublic static void main(String args []){\n    MammalInt m = new MammalInt();\n    m.eat();\n    m.travel();\n    m.onOfLegs();\n}\n</code></pre><p>}<br>```</p>\n<h4 id=\"h4-u63A5u53E3u4E0Eu7C7Bu4E0Du540Cu70B9\"><a name=\"接口与类不同点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>接口与类不同点</h4><ul>\n<li><p>接口并不是类,编写接口的方式和类很相似,但是属于不同的概念.<br>类描述对象的属性和方法,接口则包含类要实现的方法<br>除非要实现接口的类是抽象类,否则该类要定义接口的所有方法</p>\n</li><li><p>接口无法被实例化,但是可以被实现.一个实现接口的类,必须实现接口内所描述的所有方法,否者必须声明为抽象类.</p>\n</li><li><p>接口与类相似点：</p>\n<ul>\n<li>一个接口可以有多个方法。</li><li>接口文件保存在 .java 结尾的文件中，文件名使用接口名。</li><li>接口的字节码文件保存在 .class 结尾的文件中。</li><li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</li></ul>\n</li><li><p>接口与类的区别：</p>\n<ul>\n<li>接口不能用于实例化对象。</li><li>接口没有构造方法。</li><li>接口中所有的方法必须是抽象方法。</li><li>接口不能包含成员变量，除了 static 和 final 变量。</li><li>接口不是被类继承了，而是要被类实现。</li><li>接口支持多继承。</li></ul>\n</li><li><p>接口成员特点</p>\n<ul>\n<li>成员变量: 接口的变量默认是常量无法修改, 只能是常量,并且是静态的,<pre><code>              默认修饰的 public static final\n</code></pre></li><li>构造方法:<pre><code>      接口没有构造方法\n</code></pre></li><li>成员方法: 只能是抽象方法<pre><code>            默认修饰方法 public abstract\n            建议手动给出\n</code></pre></li></ul>\n</li></ul>\n<p>所有的都默认继承一个类: object();<br>类object是类层次结构的根类.每个类都使用object作为超类</p>\n', '#### 类的概念\n##### 类\n* 一个类可以包含以下类型变量：\n	* 局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。\n			变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。\n	* 成员变量：成员变量是定义在类中，方法体之外的变量。\n			这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。\n	* 类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。\n	* \n	每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。\n	在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法\n	\n<!--more-->\n\n##### 抽象类\n- 抽象类和抽象方法都使用 abstract 关键字进行声明。抽象类一般会包含抽象方法，抽象方法一定位于抽象类中。\n- 抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。\n```\npublic abstract class AbstractClassExample {\n\n    protected int x;\n    private int y;\n\n    public abstract void func1();\n\n    public void func2() {\n        System.out.println(\"func2\");\n    }\n}\n\npublic class AbstractExtendClassExample extends AbstractClassExample {\n    @Override\n    public void func1() {\n        System.out.println(\"func1\");\n    }\n}\n```\n\n#### 对象\n* 创建对象\n对象是根据类创建的。在Java中，使用关键字new来创建一个新的对象。创建对象需要以下三步：\n* 声明：声明一个对象，包括对象名称和对象类型。\n* 实例化：使用关键字new来创建一个对象。\n* 初始化：使用new创建对象时，会调用构造方法初始化对象。\n\n#### 接口\n- 接口: java编程语言中的抽象类型,是抽象方法的集合,接口通常以interface来声明.\n	* 一个类通过继承的接口的方式,从而继承接口的抽象方法.\n	* 类实现接口通常用implements表示\n		* 格式: class 类名 implements 接口名{}\n	* 接口不能实例化,需要用多态的方式去实现,接口子类重写\n	* 接口的子类\n		* 可以是抽象类,但是意义不大\n		* 可以是具体类,要重写接口中的所有的抽象方法(推荐)\n- 类实现接口\n		当类实现接口时,类要实现接口中所有的方法,否者类必须声明为抽象类,\n		类使用implements关键字实现接口.在类声明中,implement声明放在class后面\n```\n//接口\n\ninterface Animal{\n	public void eat();\n	\n	public void travel();\n}\n\npublic class MammalInt implements Animal{\n	public void eat(){\n		System.out.println(\"MammalInt eat\");\n	}\n	\n	public void travel(){\n		System.out.println(\"MammalInt travel\");\n	}\n	\n	public int onOfLegs(){\n		return 0;\n	}\n	\n	public static void main(String args []){\n		MammalInt m = new MammalInt();\n		m.eat();\n		m.travel();\n		m.onOfLegs();\n	}\n}\n```\n\n#### 接口与类不同点\n- 接口并不是类,编写接口的方式和类很相似,但是属于不同的概念.\n类描述对象的属性和方法,接口则包含类要实现的方法\n除非要实现接口的类是抽象类,否则该类要定义接口的所有方法\n		\n- 接口无法被实例化,但是可以被实现.一个实现接口的类,必须实现接口内所描述的所有方法,否者必须声明为抽象类.\n		\n- 接口与类相似点：\n	* 一个接口可以有多个方法。\n	* 接口文件保存在 .java 结尾的文件中，文件名使用接口名。\n	* 接口的字节码文件保存在 .class 结尾的文件中。\n	* 接口相应的字节码文件必须在与包名称相匹配的目录结构中。\n- 接口与类的区别：\n	* 接口不能用于实例化对象。\n	* 接口没有构造方法。\n	* 接口中所有的方法必须是抽象方法。\n	* 接口不能包含成员变量，除了 static 和 final 变量。\n	* 接口不是被类继承了，而是要被类实现。\n	* 接口支持多继承。\n			\n- 接口成员特点\n	* 成员变量: 接口的变量默认是常量无法修改, 只能是常量,并且是静态的,\n						默认修饰的 public static final\n	* 构造方法:\n				接口没有构造方法\n	* 成员方法: 只能是抽象方法\n					  默认修饰方法 public abstract\n					  建议手动给出\n				\n所有的都默认继承一个类: object();\n类object是类层次结构的根类.每个类都使用object作为超类', '1', '2019-05-09 14:25:26', '2019-05-09 14:25:26', '0');
INSERT INTO `blog` VALUES ('23', 'javaClass', '<figure class=\"image image-style-align-right\"><img src=\"/ssmBlog/uploadImage/3f6ea422-970b-41db-a646-7c2646e01b8c.jpg\"></figure><ul><li>class 类<br>class 关键字是用来声明新的 java 类的,该类是相关变量或方法的集合.类是面向对象的程序设计方法的基本构造单位.类通常代表某种实际实体.如几何形状或人.类是对象的模板.每个对象都是类的一个实例.要使用类,通常使用 new 操作符将类的对象实例化,然后调用类的方法来访问类的功能</li><li>abstract 抽象类<br>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。</li><li>final 最终的<br>final关键字可以用于声明属性,方法和类用于类,表示类不可以扩展(不能呢有子类)用于方法,表示在子类中不可以重写此方法.<br>注意:<br>一个类不可以同时是abstract又是final.abstract意味着必须扩展类,final则不能扩展.<br>一个方法不能同时是 abstract 又是 final。abstract 意味着必须重写方法，final 则不能重写方法</li><li>extends 继承、扩展<br>extends关键字用在class或interface声明中,用于指示所声明的类或接口时其名称后跟有extends关键字的类或接口的子类.子类继承父类的所有的public和protected变量和方法. 子类可以重写父类的任何final方法.一个类自能扩展一个其他的类.</li><li>static 静态<br>static 关键字可以应用于内部类（在另一个类中定义的类）、方法或字段（类的成员变量）<br>通常，static 关键字意味着应用它的实体在声明该实体的类的任何特定实例外部可用 static（内部）类可以被其他类实例化和引用（即使它是顶级类）。<br>在上面的示例中，<br>另一个类中的代码可以实例化 MyStaticClass 类， 方法是用包含它的类名来限定其名称，如 MyClass.MyStaticClass。 static 字段（类的成员变量）在类的所有实例中只存在一次。 可以从类的外部调用 static 方法，而不用首先实例化该类。这样的引用始终包括类名作为方法调用的限定符。<br>模式：public final static &lt;type&gt; varName = &lt;value&gt;;<br>通常用于声明可以在类的外部使用的类常量。 在引用这样的类常量时需要用类名加以限定。<br>在上面的示例中，另一个类可以用 MyClass.MAX_OBJECTS 形式来引用 MAX_OBJECTS 常量</li></ul>', null, '1', '2019-05-24 16:19:25', '2019-05-24 16:19:25', '0');
INSERT INTO `blog` VALUES ('24', 'javaClass', '<figure class=\"image image-style-align-right\"><img src=\"/ssmBlog/uploadImage/3f6ea422-970b-41db-a646-7c2646e01b8c.jpg\"></figure><ul><li>class 类<br>class 关键字是用来声明新的 java 类的,该类是相关变量或方法的集合.类是面向对象的程序设计方法的基本构造单位.类通常代表某种实际实体.如几何形状或人.类是对象的模板.每个对象都是类的一个实例.要使用类,通常使用 new 操作符将类的对象实例化,然后调用类的方法来访问类的功能</li><li>abstract 抽象类<br>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。</li><li>final 最终的<br>final关键字可以用于声明属性,方法和类用于类,表示类不可以扩展(不能呢有子类)用于方法,表示在子类中不可以重写此方法.<br>注意:<br>一个类不可以同时是abstract又是final.abstract意味着必须扩展类,final则不能扩展.<br>一个方法不能同时是 abstract 又是 final。abstract 意味着必须重写方法，final 则不能重写方法</li><li>extends 继承、扩展<br>extends关键字用在class或interface声明中,用于指示所声明的类或接口时其名称后跟有extends关键字的类或接口的子类.子类继承父类的所有的public和protected变量和方法. 子类可以重写父类的任何final方法.一个类自能扩展一个其他的类.</li><li>static 静态<br>static 关键字可以应用于内部类（在另一个类中定义的类）、方法或字段（类的成员变量）<br>通常，static 关键字意味着应用它的实体在声明该实体的类的任何特定实例外部可用 static（内部）类可以被其他类实例化和引用（即使它是顶级类）。<br>在上面的示例中，<br>另一个类中的代码可以实例化 MyStaticClass 类， 方法是用包含它的类名来限定其名称，如 MyClass.MyStaticClass。 static 字段（类的成员变量）在类的所有实例中只存在一次。 可以从类的外部调用 static 方法，而不用首先实例化该类。这样的引用始终包括类名作为方法调用的限定符。<br>模式：public final static &lt;type&gt; varName = &lt;value&gt;;<br>通常用于声明可以在类的外部使用的类常量。 在引用这样的类常量时需要用类名加以限定。<br>在上面的示例中，另一个类可以用 MyClass.MAX_OBJECTS 形式来引用 MAX_OBJECTS 常量</li></ul>', null, '1', '2019-05-24 16:19:38', '2019-05-24 16:19:38', '0');
INSERT INTO `blog` VALUES ('25', 'java基础(一)  常用关键字', '<h3>总览</h3><p>&nbsp; &nbsp; 基本类型\n &nbsp; &nbsp; &nbsp; &nbsp;整数\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;byte short int long\n &nbsp; &nbsp; &nbsp; &nbsp;小数\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;float double\n &nbsp; &nbsp; &nbsp; &nbsp;字符\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;char\n &nbsp; &nbsp; &nbsp; &nbsp;布尔类型(boolean)\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;true false\n &nbsp; &nbsp;访问控制\n &nbsp; &nbsp; &nbsp; &nbsp;public protected private \n &nbsp; &nbsp;程序控制\n &nbsp; &nbsp; &nbsp; &nbsp;break &nbsp; &nbsp;continue &nbsp; &nbsp;return &nbsp; &nbsp;do &nbsp; &nbsp;\n &nbsp; &nbsp; &nbsp; &nbsp;while &nbsp; &nbsp;if &nbsp; &nbsp;else &nbsp; &nbsp;for &nbsp; &nbsp;instanceof &nbsp; &nbsp;\n &nbsp; &nbsp; &nbsp; &nbsp;switch &nbsp; case &nbsp; &nbsp;default\n &nbsp; &nbsp;类,方法以及变量修饰符\n &nbsp; &nbsp; &nbsp; &nbsp; class abstract final &nbsp; &nbsp;extends static &nbsp; &nbsp;new &nbsp;implements\n &nbsp; &nbsp; &nbsp; &nbsp;native &nbsp; &nbsp;strictfp &nbsp; &nbsp;synchronized &nbsp; &nbsp;transient &nbsp; &nbsp;volatile\n &nbsp; &nbsp;异常处理\n &nbsp; &nbsp; &nbsp; &nbsp;try catch throw throws\n &nbsp; &nbsp;包相关的\n &nbsp; &nbsp; &nbsp; &nbsp;import package\n &nbsp; &nbsp;变量引用\n &nbsp; &nbsp; &nbsp; &nbsp;this super void\n &nbsp; &nbsp;保留字\n &nbsp; &nbsp; &nbsp; &nbsp;goto const\n</p><h3>详细说明</h3><h4>基本类型</h4><ul><li><strong>整数</strong></li></ul><p>&nbsp; &nbsp; &nbsp;byte: 字节型\n &nbsp; &nbsp;short: 短整型\n &nbsp; &nbsp;int: 整型\n &nbsp; &nbsp;long; 长整型\n &nbsp; &nbsp; &nbsp; &nbsp;都是java的原始数据类型\n &nbsp; &nbsp; &nbsp; &nbsp;byte 1个字节，8位【-128到127之间】\n &nbsp; &nbsp; &nbsp; &nbsp;short 2个字节，16位【-2^15 到 2^15 -1】.\n &nbsp; &nbsp; &nbsp; &nbsp;int 4个字节，32位【-2^31 到 2^31 -1】\n &nbsp; &nbsp; &nbsp; &nbsp;long 8个字节，64位【-2^63 到 2^63 -1】\n\n &nbsp; &nbsp;包装对象类\n &nbsp; &nbsp; &nbsp; &nbsp;byte: Byte\n &nbsp; &nbsp; &nbsp; &nbsp;short: Short\n &nbsp; &nbsp; &nbsp; &nbsp;int: Integer\n &nbsp; &nbsp; &nbsp; &nbsp;long: Long\n &nbsp; &nbsp;表示原始类型的包装对象类.它定义代表此类型值的范为:MIN_VALUE和MAX_VALUE常量\n\n &nbsp; &nbsp;java中所有的整数值都是32的int值,除非值后面有 l 或 L（如 235L），\n这表示该值应解释为 long\n</p><p><strong>小数</strong><br>float: 浮点<br>double: 双精度<br>都是java原始数据类型<br>float变量可以储存单精度福浮点值<br>double变量可以储存双精度的浮点值</p><p>注意:</p><ul><li>&nbsp; 由于java默认的浮点为双精度,因此要指定单精度文字(即用float),\n &nbsp;应在后面加上f,F.如: 0.11f\n</li></ul><p>由于浮点数据类型是实际数值的近视值,因此,一般不要对浮点数值进行相等的比较<br>java中的浮点数值可以代表无穷大和NAN(非数值).<br>Float和Double包装对象类用来定义常量 MIN_VALUE、MAX_VALUE、NEGATIVE_INFINITY、POSITIVE_INFINITY 和 NaN。</p><ul><li><strong>字符</strong></li></ul><p>&nbsp; &nbsp; &nbsp;char 是 Java 原始类型。char 变量可以存储一个 Unicode 字符。 \n &nbsp; &nbsp;可以使用下列 char 常量：\n &nbsp; &nbsp;\\b - 空格 \n &nbsp; &nbsp;\\f - 换页\n &nbsp; &nbsp;\\n - 换行\n &nbsp; &nbsp;\\r - 回车\n &nbsp; &nbsp;\\t - 水平制表符 \n &nbsp; &nbsp;\\\' - 单引号\n &nbsp; &nbsp;\\\" - 双引号\n &nbsp; &nbsp;\\\\ - 反斜杠\n &nbsp; &nbsp;\\xxx - 采用 xxx 编码的 Latin-1 字符\n &nbsp; &nbsp;\\x 和 \\xx 均为合法形式，但可能引起混淆\n &nbsp; &nbsp;\\uxxxx - 采用十六进制编码 xxxx 的 Unicode 字符\n\n &nbsp; &nbsp; Character 类包含一些可用来处理 char 变量的 static 方法，\n &nbsp; &nbsp; 这些方法包括 isDigit()、isLetter()、isWhitespace() 和 toUpperCase()。\n</p><ul><li>布尔值(boolean)</li></ul><p>&nbsp; &nbsp; &nbsp;ture false\n &nbsp; &nbsp;对,错\n &nbsp; &nbsp;boolean 变量的两个合法值\n</p><h4>访问控制</h4><p>public 公共的<br>public表明该数据成员、成员函数是对所有用户开放的，所有用户都可以直接进行调用</p><p>protected<br>对同一包内的类和所有子类可见。使用对象：变量、方法.protected对于子女、朋友来说，就是public的，可以自由使用，没有任何限制，而对于其他的外部class，protected就变成private。主要的作用就是用来保护子类的。它的含义在于子类可以用它修饰的成员，其他的不可以，它相当于传递给子类的一种继承的东西<br>```</p><p>private 私有的<br>private表示私有，私有的意思就是除了class自己之外，任何人都不可以直接使用<br>访问权限仅限于类的内部，是一种封装的体现，例如，大多数成员变量都是修饰符为private的，它们不希望被其他任何外部的类访问</p><h4>类,方法以及变量修饰符</h4><ul><li>class 类<br>class 关键字是用来声明新的 java 类的,该类是相关变量或方法的集合.类是面向对象的程序设计方法的基本构造单位.类通常代表某种实际实体.如几何形状或人.类是对象的模板.每个对象都是类的一个实例.要使用类,通常使用 new 操作符将类的对象实例化,然后调用类的方法来访问类的功能</li></ul><p>&nbsp;</p><ul><li>abstract 抽象类<br>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。</li></ul><p>&nbsp;</p><ul><li>final 最终的<br>final关键字可以用于声明属性,方法和类用于类,表示类不可以扩展(不能呢有子类)用于方法,表示在子类中不可以重写此方法.<br>注意:<br>一个类不可以同时是abstract又是final.abstract意味着必须扩展类,final则不能扩展.<br>一个方法不能同时是 abstract 又是 final。abstract 意味着必须重写方法，final 则不能重写方法</li></ul><p>&nbsp;</p><ul><li>extends 继承、扩展<br>extends关键字用在class或interface声明中,用于指示所声明的类或接口时其名称后跟有extends关键字的类或接口的子类.子类继承父类的所有的public和protected变量和方法. 子类可以重写父类的任何final方法.一个类自能扩展一个其他的类.</li><li>static 静态<br>static 关键字可以应用于内部类（在另一个类中定义的类）、方法或字段（类的成员变量）<br>通常，static 关键字意味着应用它的实体在声明该实体的类的任何特定实例外部可用 static（内部）类可以被其他类实例化和引用（即使它是顶级类）。<br>在上面的示例中，<br>另一个类中的代码可以实例化 MyStaticClass 类， 方法是用包含它的类名来限定其名称，如 MyClass.MyStaticClass。 static 字段（类的成员变量）在类的所有实例中只存在一次。 可以从类的外部调用 static 方法，而不用首先实例化该类。这样的引用始终包括类名作为方法调用的限定符。<br>模式：public final static &lt;type&gt; varName = &lt;value&gt;;<br>通常用于声明可以在类的外部使用的类常量。 在引用这样的类常量时需要用类名加以限定。<br>在上面的示例中，另一个类可以用 MyClass.MAX_OBJECTS 形式来引用 MAX_OBJECTS 常量</li></ul><p>&nbsp;</p><p>new<br>new关键字用于创建类的新实例<br>new关键字后面的参数必须是类名,<br>并且类名的后面必须是一组构造方法参数(必须带括号)<br>参数集合必须与类的构造方法签名匹配<br>左侧的变量的类型必须与要实例化的类或接口具有赋值兼容关系</p><p>interface<br>interface 关键字是用来声明新的java接口,接口时方法的集合.接口是java语言的一项强大的功能.任何类都可声明它实现一个或多个接口,这意味着它实现了这些接口中所定义的所有方法实现了接口的任何类都必须提供在该接口中的所有方法实现.<br>一个类可以实现多个接口</p><ul><li>implements<br>implements关键字在class声明中使用,声明类提供了implements 关键字后面名称所指定接口所声明的所有方法.类必须实现接口的中所有方法.一个类可以实现多个接口</li></ul><h4>包相关</h4><ul><li>import 引入<br>import 关键字使一个包中的一个或所有类在当前 Java 源文件中可见。可以不使用完全限定的类名来引用导入的类。 当多个包包含同名的类时，许多 Java 程序员只使用特定的 import 语句（没有“*”）来避免不确定性。</li></ul><p>&nbsp;</p><ul><li>package 包<br>package 关键字指定在 Java 源文件中声明的类所驻留的 Java 包。 package 语句（如果出现）必须是 Java 源文件中的第一个非注释性文本。 例:java.lang.Object。 如果 Java 源文件不包含 package 语句，在该文件中定义的类将位于“默认包”中。请注意，不能从非默认包中的类引用默认包中的类。</li></ul><h4>变量引用</h4><p>this<br>this 关键字用于引用当前实例。 当引用可能不明确时，可以使用 this 关键字来引用当前的实例。</p><p>void 无返回值<br>void 关键字表示 null 类型。 void 可以用作方法的返回类型，以指示该方法不返回值。</p><p>super<br>super 关键字用于引用使用该关键字的类的超类。 作为独立语句出现的 super 表示调用超类的构造方法。 super.&lt;methodName&gt;() 表示调用超类的方法。只有在如下情况中才需要采用这种用法：要调用在该类中被重写的方法，以便指定应当调用在超类中的该方法。</p>', null, '2', '2019-05-29 09:40:41', '2019-05-29 09:40:41', '0');
INSERT INTO `blog` VALUES ('26', 'java基础(一)  常用关键字', '<h3>总览</h3><p>&nbsp; &nbsp; 基本类型\n &nbsp; &nbsp; &nbsp; &nbsp;整数\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;byte short int long\n &nbsp; &nbsp; &nbsp; &nbsp;小数\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;float double\n &nbsp; &nbsp; &nbsp; &nbsp;字符\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;char\n &nbsp; &nbsp; &nbsp; &nbsp;布尔类型(boolean)\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;true false\n &nbsp; &nbsp;访问控制\n &nbsp; &nbsp; &nbsp; &nbsp;public protected private \n &nbsp; &nbsp;程序控制\n &nbsp; &nbsp; &nbsp; &nbsp;break &nbsp; &nbsp;continue &nbsp; &nbsp;return &nbsp; &nbsp;do &nbsp; &nbsp;\n &nbsp; &nbsp; &nbsp; &nbsp;while &nbsp; &nbsp;if &nbsp; &nbsp;else &nbsp; &nbsp;for &nbsp; &nbsp;instanceof &nbsp; &nbsp;\n &nbsp; &nbsp; &nbsp; &nbsp;switch &nbsp; case &nbsp; &nbsp;default\n &nbsp; &nbsp;类,方法以及变量修饰符\n &nbsp; &nbsp; &nbsp; &nbsp; class abstract final &nbsp; &nbsp;extends static &nbsp; &nbsp;new &nbsp;implements\n &nbsp; &nbsp; &nbsp; &nbsp;native &nbsp; &nbsp;strictfp &nbsp; &nbsp;synchronized &nbsp; &nbsp;transient &nbsp; &nbsp;volatile\n &nbsp; &nbsp;异常处理\n &nbsp; &nbsp; &nbsp; &nbsp;try catch throw throws\n &nbsp; &nbsp;包相关的\n &nbsp; &nbsp; &nbsp; &nbsp;import package\n &nbsp; &nbsp;变量引用\n &nbsp; &nbsp; &nbsp; &nbsp;this super void\n &nbsp; &nbsp;保留字\n &nbsp; &nbsp; &nbsp; &nbsp;goto const\n</p><h3>详细说明</h3><h4>基本类型</h4><ul><li><strong>整数</strong></li></ul><p>&nbsp; &nbsp; &nbsp;byte: 字节型\n &nbsp; &nbsp;short: 短整型\n &nbsp; &nbsp;int: 整型\n &nbsp; &nbsp;long; 长整型\n &nbsp; &nbsp; &nbsp; &nbsp;都是java的原始数据类型\n &nbsp; &nbsp; &nbsp; &nbsp;byte 1个字节，8位【-128到127之间】\n &nbsp; &nbsp; &nbsp; &nbsp;short 2个字节，16位【-2^15 到 2^15 -1】.\n &nbsp; &nbsp; &nbsp; &nbsp;int 4个字节，32位【-2^31 到 2^31 -1】\n &nbsp; &nbsp; &nbsp; &nbsp;long 8个字节，64位【-2^63 到 2^63 -1】\n\n &nbsp; &nbsp;包装对象类\n &nbsp; &nbsp; &nbsp; &nbsp;byte: Byte\n &nbsp; &nbsp; &nbsp; &nbsp;short: Short\n &nbsp; &nbsp; &nbsp; &nbsp;int: Integer\n &nbsp; &nbsp; &nbsp; &nbsp;long: Long\n &nbsp; &nbsp;表示原始类型的包装对象类.它定义代表此类型值的范为:MIN_VALUE和MAX_VALUE常量\n\n &nbsp; &nbsp;java中所有的整数值都是32的int值,除非值后面有 l 或 L（如 235L），\n这表示该值应解释为 long\n</p><p><strong>小数</strong><br>float: 浮点<br>double: 双精度<br>都是java原始数据类型<br>float变量可以储存单精度福浮点值<br>double变量可以储存双精度的浮点值</p><p>注意:</p><ul><li>&nbsp; 由于java默认的浮点为双精度,因此要指定单精度文字(即用float),\n &nbsp;应在后面加上f,F.如: 0.11f\n</li></ul><p>由于浮点数据类型是实际数值的近视值,因此,一般不要对浮点数值进行相等的比较<br>java中的浮点数值可以代表无穷大和NAN(非数值).<br>Float和Double包装对象类用来定义常量 MIN_VALUE、MAX_VALUE、NEGATIVE_INFINITY、POSITIVE_INFINITY 和 NaN。</p><ul><li><strong>字符</strong></li></ul><p>&nbsp; &nbsp; &nbsp;char 是 Java 原始类型。char 变量可以存储一个 Unicode 字符。 \n &nbsp; &nbsp;可以使用下列 char 常量：\n &nbsp; &nbsp;\\b - 空格 \n &nbsp; &nbsp;\\f - 换页\n &nbsp; &nbsp;\\n - 换行\n &nbsp; &nbsp;\\r - 回车\n &nbsp; &nbsp;\\t - 水平制表符 \n &nbsp; &nbsp;\\\' - 单引号\n &nbsp; &nbsp;\\\" - 双引号\n &nbsp; &nbsp;\\\\ - 反斜杠\n &nbsp; &nbsp;\\xxx - 采用 xxx 编码的 Latin-1 字符\n &nbsp; &nbsp;\\x 和 \\xx 均为合法形式，但可能引起混淆\n &nbsp; &nbsp;\\uxxxx - 采用十六进制编码 xxxx 的 Unicode 字符\n\n &nbsp; &nbsp; Character 类包含一些可用来处理 char 变量的 static 方法，\n &nbsp; &nbsp; 这些方法包括 isDigit()、isLetter()、isWhitespace() 和 toUpperCase()。\n</p><ul><li>布尔值(boolean)</li></ul><p>&nbsp; &nbsp; &nbsp;ture false\n &nbsp; &nbsp;对,错\n &nbsp; &nbsp;boolean 变量的两个合法值\n</p><h4>访问控制</h4><p>public 公共的<br>public表明该数据成员、成员函数是对所有用户开放的，所有用户都可以直接进行调用</p><p>protected<br>对同一包内的类和所有子类可见。使用对象：变量、方法.protected对于子女、朋友来说，就是public的，可以自由使用，没有任何限制，而对于其他的外部class，protected就变成private。主要的作用就是用来保护子类的。它的含义在于子类可以用它修饰的成员，其他的不可以，它相当于传递给子类的一种继承的东西<br>```</p><p>private 私有的<br>private表示私有，私有的意思就是除了class自己之外，任何人都不可以直接使用<br>访问权限仅限于类的内部，是一种封装的体现，例如，大多数成员变量都是修饰符为private的，它们不希望被其他任何外部的类访问</p><h4>类,方法以及变量修饰符</h4><ul><li>class 类<br>class 关键字是用来声明新的 java 类的,该类是相关变量或方法的集合.类是面向对象的程序设计方法的基本构造单位.类通常代表某种实际实体.如几何形状或人.类是对象的模板.每个对象都是类的一个实例.要使用类,通常使用 new 操作符将类的对象实例化,然后调用类的方法来访问类的功能</li></ul><p>&nbsp;</p><ul><li>abstract 抽象类<br>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。</li></ul><p>&nbsp;</p><ul><li>final 最终的<br>final关键字可以用于声明属性,方法和类用于类,表示类不可以扩展(不能呢有子类)用于方法,表示在子类中不可以重写此方法.<br>注意:<br>一个类不可以同时是abstract又是final.abstract意味着必须扩展类,final则不能扩展.<br>一个方法不能同时是 abstract 又是 final。abstract 意味着必须重写方法，final 则不能重写方法</li></ul><p>&nbsp;</p><ul><li>extends 继承、扩展<br>extends关键字用在class或interface声明中,用于指示所声明的类或接口时其名称后跟有extends关键字的类或接口的子类.子类继承父类的所有的public和protected变量和方法. 子类可以重写父类的任何final方法.一个类自能扩展一个其他的类.</li><li>static 静态<br>static 关键字可以应用于内部类（在另一个类中定义的类）、方法或字段（类的成员变量）<br>通常，static 关键字意味着应用它的实体在声明该实体的类的任何特定实例外部可用 static（内部）类可以被其他类实例化和引用（即使它是顶级类）。<br>在上面的示例中，<br>另一个类中的代码可以实例化 MyStaticClass 类， 方法是用包含它的类名来限定其名称，如 MyClass.MyStaticClass。 static 字段（类的成员变量）在类的所有实例中只存在一次。 可以从类的外部调用 static 方法，而不用首先实例化该类。这样的引用始终包括类名作为方法调用的限定符。<br>模式：public final static &lt;type&gt; varName = &lt;value&gt;;<br>通常用于声明可以在类的外部使用的类常量。 在引用这样的类常量时需要用类名加以限定。<br>在上面的示例中，另一个类可以用 MyClass.MAX_OBJECTS 形式来引用 MAX_OBJECTS 常量</li></ul><p>&nbsp;</p><p>new<br>new关键字用于创建类的新实例<br>new关键字后面的参数必须是类名,<br>并且类名的后面必须是一组构造方法参数(必须带括号)<br>参数集合必须与类的构造方法签名匹配<br>左侧的变量的类型必须与要实例化的类或接口具有赋值兼容关系</p><p>interface<br>interface 关键字是用来声明新的java接口,接口时方法的集合.接口是java语言的一项强大的功能.任何类都可声明它实现一个或多个接口,这意味着它实现了这些接口中所定义的所有方法实现了接口的任何类都必须提供在该接口中的所有方法实现.<br>一个类可以实现多个接口</p><ul><li>implements<br>implements关键字在class声明中使用,声明类提供了implements 关键字后面名称所指定接口所声明的所有方法.类必须实现接口的中所有方法.一个类可以实现多个接口</li></ul><h4>包相关</h4><ul><li>import 引入<br>import 关键字使一个包中的一个或所有类在当前 Java 源文件中可见。可以不使用完全限定的类名来引用导入的类。 当多个包包含同名的类时，许多 Java 程序员只使用特定的 import 语句（没有“*”）来避免不确定性。</li></ul><p>&nbsp;</p><ul><li>package 包<br>package 关键字指定在 Java 源文件中声明的类所驻留的 Java 包。 package 语句（如果出现）必须是 Java 源文件中的第一个非注释性文本。 例:java.lang.Object。 如果 Java 源文件不包含 package 语句，在该文件中定义的类将位于“默认包”中。请注意，不能从非默认包中的类引用默认包中的类。</li></ul><h4>变量引用</h4><p>this<br>this 关键字用于引用当前实例。 当引用可能不明确时，可以使用 this 关键字来引用当前的实例。</p><p>void 无返回值<br>void 关键字表示 null 类型。 void 可以用作方法的返回类型，以指示该方法不返回值。</p><p>super<br>super 关键字用于引用使用该关键字的类的超类。 作为独立语句出现的 super 表示调用超类的构造方法。 super.&lt;methodName&gt;() 表示调用超类的方法。只有在如下情况中才需要采用这种用法：要调用在该类中被重写的方法，以便指定应当调用在超类中的该方法。</p>', null, '1', '2019-05-29 09:43:06', '2019-05-29 09:43:06', '0');
INSERT INTO `blog` VALUES ('27', 'java基础(一)  常用关键字', '<h3>总览</h3><p>&nbsp; &nbsp; 基本类型\n &nbsp; &nbsp; &nbsp; &nbsp;整数\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;byte short int long\n &nbsp; &nbsp; &nbsp; &nbsp;小数\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;float double\n &nbsp; &nbsp; &nbsp; &nbsp;字符\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;char\n &nbsp; &nbsp; &nbsp; &nbsp;布尔类型(boolean)\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;true false\n &nbsp; &nbsp;访问控制\n &nbsp; &nbsp; &nbsp; &nbsp;public protected private \n &nbsp; &nbsp;程序控制\n &nbsp; &nbsp; &nbsp; &nbsp;break &nbsp; &nbsp;continue &nbsp; &nbsp;return &nbsp; &nbsp;do &nbsp; &nbsp;\n &nbsp; &nbsp; &nbsp; &nbsp;while &nbsp; &nbsp;if &nbsp; &nbsp;else &nbsp; &nbsp;for &nbsp; &nbsp;instanceof &nbsp; &nbsp;\n &nbsp; &nbsp; &nbsp; &nbsp;switch &nbsp; case &nbsp; &nbsp;default\n &nbsp; &nbsp;类,方法以及变量修饰符\n &nbsp; &nbsp; &nbsp; &nbsp; class abstract final &nbsp; &nbsp;extends static &nbsp; &nbsp;new &nbsp;implements\n &nbsp; &nbsp; &nbsp; &nbsp;native &nbsp; &nbsp;strictfp &nbsp; &nbsp;synchronized &nbsp; &nbsp;transient &nbsp; &nbsp;volatile\n &nbsp; &nbsp;异常处理\n &nbsp; &nbsp; &nbsp; &nbsp;try catch throw throws\n &nbsp; &nbsp;包相关的\n &nbsp; &nbsp; &nbsp; &nbsp;import package\n &nbsp; &nbsp;变量引用\n &nbsp; &nbsp; &nbsp; &nbsp;this super void\n &nbsp; &nbsp;保留字\n &nbsp; &nbsp; &nbsp; &nbsp;goto const\n</p><h3>详细说明</h3><h4>基本类型</h4><ul><li><strong>整数</strong></li></ul><p>&nbsp; &nbsp; &nbsp;byte: 字节型\n &nbsp; &nbsp;short: 短整型\n &nbsp; &nbsp;int: 整型\n &nbsp; &nbsp;long; 长整型\n &nbsp; &nbsp; &nbsp; &nbsp;都是java的原始数据类型\n &nbsp; &nbsp; &nbsp; &nbsp;byte 1个字节，8位【-128到127之间】\n &nbsp; &nbsp; &nbsp; &nbsp;short 2个字节，16位【-2^15 到 2^15 -1】.\n &nbsp; &nbsp; &nbsp; &nbsp;int 4个字节，32位【-2^31 到 2^31 -1】\n &nbsp; &nbsp; &nbsp; &nbsp;long 8个字节，64位【-2^63 到 2^63 -1】\n\n &nbsp; &nbsp;包装对象类\n &nbsp; &nbsp; &nbsp; &nbsp;byte: Byte\n &nbsp; &nbsp; &nbsp; &nbsp;short: Short\n &nbsp; &nbsp; &nbsp; &nbsp;int: Integer\n &nbsp; &nbsp; &nbsp; &nbsp;long: Long\n &nbsp; &nbsp;表示原始类型的包装对象类.它定义代表此类型值的范为:MIN_VALUE和MAX_VALUE常量\n\n &nbsp; &nbsp;java中所有的整数值都是32的int值,除非值后面有 l 或 L（如 235L），\n这表示该值应解释为 long\n</p><p><strong>小数</strong><br>float: 浮点<br>double: 双精度<br>都是java原始数据类型<br>float变量可以储存单精度福浮点值<br>double变量可以储存双精度的浮点值</p><p>注意:</p><ul><li>&nbsp; 由于java默认的浮点为双精度,因此要指定单精度文字(即用float),\n &nbsp;应在后面加上f,F.如: 0.11f\n</li></ul><p>由于浮点数据类型是实际数值的近视值,因此,一般不要对浮点数值进行相等的比较<br>java中的浮点数值可以代表无穷大和NAN(非数值).<br>Float和Double包装对象类用来定义常量 MIN_VALUE、MAX_VALUE、NEGATIVE_INFINITY、POSITIVE_INFINITY 和 NaN。</p><ul><li><strong>字符</strong></li></ul><p>&nbsp; &nbsp; &nbsp;char 是 Java 原始类型。char 变量可以存储一个 Unicode 字符。 \n &nbsp; &nbsp;可以使用下列 char 常量：\n &nbsp; &nbsp;\\b - 空格 \n &nbsp; &nbsp;\\f - 换页\n &nbsp; &nbsp;\\n - 换行\n &nbsp; &nbsp;\\r - 回车\n &nbsp; &nbsp;\\t - 水平制表符 \n &nbsp; &nbsp;\\\' - 单引号\n &nbsp; &nbsp;\\\" - 双引号\n &nbsp; &nbsp;\\\\ - 反斜杠\n &nbsp; &nbsp;\\xxx - 采用 xxx 编码的 Latin-1 字符\n &nbsp; &nbsp;\\x 和 \\xx 均为合法形式，但可能引起混淆\n &nbsp; &nbsp;\\uxxxx - 采用十六进制编码 xxxx 的 Unicode 字符\n\n &nbsp; &nbsp; Character 类包含一些可用来处理 char 变量的 static 方法，\n &nbsp; &nbsp; 这些方法包括 isDigit()、isLetter()、isWhitespace() 和 toUpperCase()。\n</p><ul><li>布尔值(boolean)</li></ul><p>&nbsp; &nbsp; &nbsp;ture false\n &nbsp; &nbsp;对,错\n &nbsp; &nbsp;boolean 变量的两个合法值\n</p><h4>访问控制</h4><p>public 公共的<br>public表明该数据成员、成员函数是对所有用户开放的，所有用户都可以直接进行调用</p><p>protected<br>对同一包内的类和所有子类可见。使用对象：变量、方法.protected对于子女、朋友来说，就是public的，可以自由使用，没有任何限制，而对于其他的外部class，protected就变成private。主要的作用就是用来保护子类的。它的含义在于子类可以用它修饰的成员，其他的不可以，它相当于传递给子类的一种继承的东西<br>```</p><p>private 私有的<br>private表示私有，私有的意思就是除了class自己之外，任何人都不可以直接使用<br>访问权限仅限于类的内部，是一种封装的体现，例如，大多数成员变量都是修饰符为private的，它们不希望被其他任何外部的类访问</p><h4>类,方法以及变量修饰符</h4><ul><li>class 类<br>class 关键字是用来声明新的 java 类的,该类是相关变量或方法的集合.类是面向对象的程序设计方法的基本构造单位.类通常代表某种实际实体.如几何形状或人.类是对象的模板.每个对象都是类的一个实例.要使用类,通常使用 new 操作符将类的对象实例化,然后调用类的方法来访问类的功能</li></ul><p>&nbsp;</p><ul><li>abstract 抽象类<br>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。</li></ul><p>&nbsp;</p><ul><li>final 最终的<br>final关键字可以用于声明属性,方法和类用于类,表示类不可以扩展(不能呢有子类)用于方法,表示在子类中不可以重写此方法.<br>注意:<br>一个类不可以同时是abstract又是final.abstract意味着必须扩展类,final则不能扩展.<br>一个方法不能同时是 abstract 又是 final。abstract 意味着必须重写方法，final 则不能重写方法</li></ul><p>&nbsp;</p><ul><li>extends 继承、扩展<br>extends关键字用在class或interface声明中,用于指示所声明的类或接口时其名称后跟有extends关键字的类或接口的子类.子类继承父类的所有的public和protected变量和方法. 子类可以重写父类的任何final方法.一个类自能扩展一个其他的类.</li><li>static 静态<br>static 关键字可以应用于内部类（在另一个类中定义的类）、方法或字段（类的成员变量）<br>通常，static 关键字意味着应用它的实体在声明该实体的类的任何特定实例外部可用 static（内部）类可以被其他类实例化和引用（即使它是顶级类）。<br>在上面的示例中，<br>另一个类中的代码可以实例化 MyStaticClass 类， 方法是用包含它的类名来限定其名称，如 MyClass.MyStaticClass。 static 字段（类的成员变量）在类的所有实例中只存在一次。 可以从类的外部调用 static 方法，而不用首先实例化该类。这样的引用始终包括类名作为方法调用的限定符。<br>模式：public final static &lt;type&gt; varName = &lt;value&gt;;<br>通常用于声明可以在类的外部使用的类常量。 在引用这样的类常量时需要用类名加以限定。<br>在上面的示例中，另一个类可以用 MyClass.MAX_OBJECTS 形式来引用 MAX_OBJECTS 常量</li></ul><p>&nbsp;</p><p>new<br>new关键字用于创建类的新实例<br>new关键字后面的参数必须是类名,<br>并且类名的后面必须是一组构造方法参数(必须带括号)<br>参数集合必须与类的构造方法签名匹配<br>左侧的变量的类型必须与要实例化的类或接口具有赋值兼容关系</p><p>interface<br>interface 关键字是用来声明新的java接口,接口时方法的集合.接口是java语言的一项强大的功能.任何类都可声明它实现一个或多个接口,这意味着它实现了这些接口中所定义的所有方法实现了接口的任何类都必须提供在该接口中的所有方法实现.<br>一个类可以实现多个接口</p><ul><li>implements<br>implements关键字在class声明中使用,声明类提供了implements 关键字后面名称所指定接口所声明的所有方法.类必须实现接口的中所有方法.一个类可以实现多个接口</li></ul><h4>包相关</h4><ul><li>import 引入<br>import 关键字使一个包中的一个或所有类在当前 Java 源文件中可见。可以不使用完全限定的类名来引用导入的类。 当多个包包含同名的类时，许多 Java 程序员只使用特定的 import 语句（没有“*”）来避免不确定性。</li></ul><p>&nbsp;</p><ul><li>package 包<br>package 关键字指定在 Java 源文件中声明的类所驻留的 Java 包。 package 语句（如果出现）必须是 Java 源文件中的第一个非注释性文本。 例:java.lang.Object。 如果 Java 源文件不包含 package 语句，在该文件中定义的类将位于“默认包”中。请注意，不能从非默认包中的类引用默认包中的类。</li></ul><h4>变量引用</h4><p>this<br>this 关键字用于引用当前实例。 当引用可能不明确时，可以使用 this 关键字来引用当前的实例。</p><p>void 无返回值<br>void 关键字表示 null 类型。 void 可以用作方法的返回类型，以指示该方法不返回值。</p><p>super<br>super 关键字用于引用使用该关键字的类的超类。 作为独立语句出现的 super 表示调用超类的构造方法。 super.&lt;methodName&gt;() 表示调用超类的方法。只有在如下情况中才需要采用这种用法：要调用在该类中被重写的方法，以便指定应当调用在超类中的该方法。</p>', null, '2', '2019-05-29 09:43:46', '2019-05-29 09:43:46', '0');
INSERT INTO `blog` VALUES ('28', 'java基础(二) 基础知识', '<h4>1.常量和变量</h4><ul><li><strong>什么是常量?</strong><br>值不会变的是常量<br>常量在程序运行时是不能被修改的。</li><li><strong>什么是变量?</strong><br>在作用域之间,在该数据类型范围内可以变化的的一个量.</li></ul><p>&nbsp;</p><ul><li>声明变量(定义变量) &nbsp;格式: 数据类型 变量名;\n</li><li>变量赋值: &nbsp;变量名 = 常量名;\n &nbsp;数据类型 变量名 = 常量名;\n</li></ul><h4>2.进制</h4><ul><li><strong>二进制</strong><br>0和1 前缀0B或者0b 比如：0B1001 转为十进制是9</li><li><strong>八进制</strong><br>0-7 前缀0 比如：0103</li></ul><p>&nbsp;</p><ul><li>十进制【我们常用的】<br>0-9 没有前缀</li></ul><p>&nbsp;</p><ul><li><strong>十进制</strong><br>0-9 和 A-F 前缀0x或者0X 比如：0x123</li><li><strong>进制转换</strong><br>任何进制转化为十进制公式：系数 <i>底数 ^ 指数</i><br><i>```java</i><br><i>0b1010 = 1 </i>2^3 + 0 <i>2^2 + 1</i>2^1 + 0*2^0 &nbsp; &nbsp; &nbsp; &nbsp; = 8 + 0 + 2 + 0\n &nbsp; &nbsp; &nbsp; &nbsp; = 10\n</li></ul><p>0123 = 1<i>8^2 + 2</i>8^1 + 3*8^0<br>= 64 + 16 + 3<br>= 83</p><p>0x123 = 1<i>16^2 + 2</i>16^1 + 3*16^0<br>= 256 + 32 + 3<br>= 291</p><p>#### 3.反码和补码\n &nbsp; &nbsp;正数的补码和原码是一样的\n5\n原码：0000 0101\n补码：0000 0101\n &nbsp; &nbsp;* 负数的补码是它的反码加1\n\n-5：\n原码：1000 0101\n反码：1111 1010\n &nbsp; &nbsp;+ &nbsp; &nbsp; &nbsp; &nbsp; 1\n------------------\n补码 &nbsp;1111 1011\n#### 4.Java数据类型\n\n- **基本数据类型**\n- byte类型\n &nbsp; &nbsp;* 1个字节，8位【-128到127之间】\n- short类型\n &nbsp; &nbsp;* 2个字节，16位【-2^15 到 2^15 -1】\n- int类型\n &nbsp; &nbsp;* 4个字节，32位【-2^31 到 2^31 -1】\n- float类型【浮点型】\n &nbsp; &nbsp;* 4个字节，32位\n- double类型【浮点型】\n &nbsp; &nbsp;* 8个字节，64位\n- long类型\n &nbsp; &nbsp;* 8个字节，64位【-2^63 &nbsp;到 2^63 -1】\n- char类型\n &nbsp; &nbsp;* 2个字节，16位【1个汉字刚好2个字节】\n- boolean类型\n &nbsp; &nbsp;* 1个字节，true和false\n- **引用类型**\n* 在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。\n* 对象、数组都是引用数据类型。\n* 所有引用类型的默认值都是null。\n* 一个引用变量可以用来引用任何与之兼容的类型。\n* 例子：Site site = new Site(\"Runoob\")。\n- **数据类型的转换**\n- 默认转换\n &nbsp; &nbsp;* 1：byte,short,char—int—long—float—double\n &nbsp; &nbsp;* 2：byte,short,char相互之间补转换，他们参与运算首先转换为int类型\n- 向上转换: 自动转化\n &nbsp; &nbsp;* double d = 1.234f;\n- 向下转换: 需要强制转换\n &nbsp; &nbsp;* 格式: 目标类型 变量名 = (目标类型)值或变量名\n &nbsp; &nbsp;* int a = (int) 15.7f;\n &nbsp; &nbsp;* 注意:\n &nbsp; &nbsp;1:在java中，任何一个整数默认为 int 类型 (1)\n &nbsp; &nbsp;2:在java种，任何一个小数，默认为 double 类型( 1.0)\n &nbsp; &nbsp;3:123L 或者 1231 编译器会将该数当成long类型\n &nbsp; &nbsp;4:12.345f 或者12.345F 编译器会将该数当成float类型\n\n#### 字节码\n- **常见的字节码**\n* ASCII 码\n* GBK码\n* Unicode码【占2个字节】\n\n#### 运算符\n- **常见的运算符有哪些**\n &nbsp; &nbsp;* 算术运算符\n &nbsp; &nbsp;* 赋值运算符\n &nbsp; &nbsp;* 关系运算符\n &nbsp; &nbsp;* 逻辑运算符\n &nbsp; &nbsp;* 三目运算符\n &nbsp; &nbsp;* 特殊运算符: 位运算符\n- **算术运算符**\n+, &nbsp;-, &nbsp;*, &nbsp;/, &nbsp;%(取余), ++(自加), --(自减)\n- **赋值运算符**\n= ， += ， -= ， *= ， /= ， %=\n- **关系运算符**\n==, &gt;, &lt;, =&gt;, &lt;=, !=\n- **逻辑运算符**\n</p><p>&amp; ，^ ，| ，&amp;&amp; ，|| ，！ ， ^</p><p>- **三目运算符**\na == b ？ c ： d\n格式：(条件表达式)？表达式1：表达式2\n- **位运算符**\n&amp; , | , ^ , ~ , &lt;&lt; , &gt;&gt; , &gt;&gt;&gt;\n\n#### Java基本语句结构\n- **语句结构种类**\n &nbsp; &nbsp;* 顺序结构\n &nbsp; &nbsp;* 选择结构\n &nbsp; &nbsp;* 循环结构\n- **顺序结构**\n &nbsp; &nbsp;* 从上到下依次执行\n- **选择结构【可以嵌套】**\n &nbsp; &nbsp;* if ， if else ， if else if …… else\n &nbsp; &nbsp;* switch case【支持byte，short，char，int，String】\n- **循环结构**\n* for\nfor(初始化语句;判断条件语句;控制条件语句) {\n &nbsp; &nbsp; &nbsp; &nbsp; 循环体语句;\n}\n第一步：先执行初始化语句，只执行一次\n第二步：执行判断条件语句\n第三部：执行循环体语句\n第四步：执行控制条件语句，然后再执行循环体语句【循环】\n* while\n初始化语句;\nwhile(判断条件语句) {\n &nbsp; &nbsp;循环体语句;\n &nbsp; &nbsp;控制条件语句;\n}\n* do while\ndo {\n &nbsp; &nbsp; &nbsp; &nbsp; 循环体语句;\n}while((判断条件语句);\n\n#### Java方法\n- **定义**\n方法就是完成特定功能的代码块\n</p><p>1.系统方法，只需要会使用，不需要知道内部的结构<br>2.自定义方法: 方法内部实现需要我们来写<br>3.方法内部不能再嵌套方法</p><p>- **格式**\n修饰符 返回类型 方法名(参数类型 参数名,...){\n &nbsp; &nbsp;函数体\n &nbsp; &nbsp;return 返回值\n}\n* 修饰符: public static或者直接是public或是其他的private\n* 返回类型: 所有的数据类型(基本类型: int, long,float,char...,引用数据类型: String)\n* 方法名: 采用驼峰式,首字母一般小写,要见名知意\n* 参数类型: 所有的数据类型,如果一个方法没有返回值,则这个方法值类型为void\n* 参数名: 变量\n* 返回值: 即返回结果(这个结果必须与返回类型一致)\n\n#### 数组\n- **数组的概念**\n* 数组是一个容器,可以储存多个变量,这些变量的数据类型必须一致\n* 数组既可以储存基本数据类型,也可以储存引用数据类型\n\n- **一维数组**\n* 数组格式定义\n &nbsp; &nbsp;格式一: 数据类型【】 数组名\n &nbsp; &nbsp;格式二: 数据类型 数组名【】\nint[] a; //定义了一个int类型的数组a;\nint a[]; //定义了一个int类型的a数组;\n- 数组的初始化\n &nbsp; &nbsp;* java的数组必须初始化,然后才能使用\n &nbsp; &nbsp;* 数组初始化: 就是为数组元素中的数组分配内存空间,并为每一个数组元素赋值\n- 初始化分类\n &nbsp; &nbsp;* &nbsp;动态初始化: 只指定长度,由系统给出初始值\n &nbsp; &nbsp;* 静态初始化: 给出初始值,由系统给出长度\n &nbsp; &nbsp;* 注意事项: 这两种方式,只能给出一种,不能动静结合\n- **二维数组**\n* 数组定义格式\n &nbsp; &nbsp;* 数据类型[][] 变量名 = new 数据类型[m][n];\n &nbsp; &nbsp;* m表示这个二维数组有多少个一维数组\n &nbsp; &nbsp;* n表示每一个一维数组的元素个数\nint[][] arr = new int[3][2];\n定义了一个二维数组arr\n这个二维数组有3个一维数组，名称是arr[0],arr[1],arr[2]\n每个一维数组有2个元素，可以通过arr[m][n]来获取,\n</p><p>```</p><h4>数据结构</h4><p><strong>枚举: Enumeration</strong><br><strong>位集合: BitSet</strong><br><strong>向量: Vector</strong><br><strong>栈: Stack</strong><br><strong>字典: Dictionary</strong><br><strong>哈希表: Hashtable</strong><br><strong>属性: Properties</strong></p><ul><li>枚举:<ul><li>枚举（Enumeration）接口虽然它本身不属于数据结构,但它在其他数据结构的范畴里应用很广。</li><li>枚举（The Enumeration）接口定义了一种从数据结构中取回连续元素的方式。</li></ul></li><li>位集合（BitSet）<ul><li>位集合类实现了一组可以单独设置和清除的位或标志。</li><li>该类在处理一组布尔值的时候非常有用，你只需要给每个值赋值一”位”，<br>然后对位进行适当的设置或清除，就可以对布尔值进行操作了。</li></ul></li><li>向量（Vector）<ul><li>向量（Vector）类和传统数组非常相似，但是Vector的大小能根据需要动态的变化。<br>和数组一样，Vector对象的元素也能通过索引访问。</li><li>使用Vector类最主要的好处就是在创建对象的时候不必给对象指定大小，它的大小会根据需要动态的变化。</li></ul></li><li>栈（Stack）<ul><li>栈（Stack）实现了一个后进先出（LIFO）的数据结构。</li><li>你可以把栈理解为对象的垂直分布的栈，当你添加一个新元素时，就将新元素放在其他元素的顶部。</li><li>当你从栈中取元素的时候，就从栈顶取一个元素。换句话说，最后进栈的元素最先被取出。</li><li>字典（Dictionary）<br>字典（Dictionary） 类是一个抽象类，它定义了键映射到值的数据结构。<br>当你想要通过特定的键而不是整数索引来访问数据的时候，这时候应该使用Dictionary。<br>由于Dictionary类是抽象类，所以它只提供了键映射到值的数据结构，而没有提供特定的实现。</li></ul></li><li>哈希表（Hashtable）<br>Hashtable类提供了一种在用户定义键结构的基础上来组织数据的手段。<br>例如，在地址列表的哈希表中，你可以根据邮政编码作为键来存储和排序数据，而不是通过人名。<br>哈希表键的具体含义完全取决于哈希表的使用情景和它包含的数据。</li><li>属性（Properties）<br>Properties 继承于 Hashtable.Properties 类表示了一个持久的属性集.属性列表中每个键及其对应值都是一个字符串。<br>Properties 类被许多Java类使用。例如，在获取环境变量时它就作为System.getProperties()方法的返回值。</li></ul>', null, '1', '2019-05-29 09:48:22', '2019-05-29 09:48:22', '0');
INSERT INTO `blog` VALUES ('29', 'java基础(二) 基础知识', '<h4>1.常量和变量</h4><ul><li><strong>什么是常量?</strong><br>值不会变的是常量<br>常量在程序运行时是不能被修改的。</li><li><strong>什么是变量?</strong><br>在作用域之间,在该数据类型范围内可以变化的的一个量.</li></ul><p>&nbsp;</p><ul><li>声明变量(定义变量) &nbsp;格式: 数据类型 变量名;\n</li><li>变量赋值: &nbsp;变量名 = 常量名;\n &nbsp;数据类型 变量名 = 常量名;\n</li></ul><h4>2.进制</h4><ul><li><strong>二进制</strong><br>0和1 前缀0B或者0b 比如：0B1001 转为十进制是9</li><li><strong>八进制</strong><br>0-7 前缀0 比如：0103</li></ul><p>&nbsp;</p><ul><li>十进制【我们常用的】<br>0-9 没有前缀</li></ul><p>&nbsp;</p><ul><li><strong>十进制</strong><br>0-9 和 A-F 前缀0x或者0X 比如：0x123</li><li><strong>进制转换</strong><br>任何进制转化为十进制公式：系数 <i>底数 ^ 指数</i><br><i>```java</i><br><i>0b1010 = 1 </i>2^3 + 0 <i>2^2 + 1</i>2^1 + 0*2^0 &nbsp; &nbsp; &nbsp; &nbsp; = 8 + 0 + 2 + 0\n &nbsp; &nbsp; &nbsp; &nbsp; = 10\n</li></ul><p>0123 = 1<i>8^2 + 2</i>8^1 + 3*8^0<br>= 64 + 16 + 3<br>= 83</p><p>0x123 = 1<i>16^2 + 2</i>16^1 + 3*16^0<br>= 256 + 32 + 3<br>= 291</p><p>#### 3.反码和补码\n &nbsp; &nbsp;正数的补码和原码是一样的\n5\n原码：0000 0101\n补码：0000 0101\n &nbsp; &nbsp;* 负数的补码是它的反码加1\n\n-5：\n原码：1000 0101\n反码：1111 1010\n &nbsp; &nbsp;+ &nbsp; &nbsp; &nbsp; &nbsp; 1\n------------------\n补码 &nbsp;1111 1011\n#### 4.Java数据类型\n\n- **基本数据类型**\n- byte类型\n &nbsp; &nbsp;* 1个字节，8位【-128到127之间】\n- short类型\n &nbsp; &nbsp;* 2个字节，16位【-2^15 到 2^15 -1】\n- int类型\n &nbsp; &nbsp;* 4个字节，32位【-2^31 到 2^31 -1】\n- float类型【浮点型】\n &nbsp; &nbsp;* 4个字节，32位\n- double类型【浮点型】\n &nbsp; &nbsp;* 8个字节，64位\n- long类型\n &nbsp; &nbsp;* 8个字节，64位【-2^63 &nbsp;到 2^63 -1】\n- char类型\n &nbsp; &nbsp;* 2个字节，16位【1个汉字刚好2个字节】\n- boolean类型\n &nbsp; &nbsp;* 1个字节，true和false\n- **引用类型**\n* 在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。\n* 对象、数组都是引用数据类型。\n* 所有引用类型的默认值都是null。\n* 一个引用变量可以用来引用任何与之兼容的类型。\n* 例子：Site site = new Site(\"Runoob\")。\n- **数据类型的转换**\n- 默认转换\n &nbsp; &nbsp;* 1：byte,short,char—int—long—float—double\n &nbsp; &nbsp;* 2：byte,short,char相互之间补转换，他们参与运算首先转换为int类型\n- 向上转换: 自动转化\n &nbsp; &nbsp;* double d = 1.234f;\n- 向下转换: 需要强制转换\n &nbsp; &nbsp;* 格式: 目标类型 变量名 = (目标类型)值或变量名\n &nbsp; &nbsp;* int a = (int) 15.7f;\n &nbsp; &nbsp;* 注意:\n &nbsp; &nbsp;1:在java中，任何一个整数默认为 int 类型 (1)\n &nbsp; &nbsp;2:在java种，任何一个小数，默认为 double 类型( 1.0)\n &nbsp; &nbsp;3:123L 或者 1231 编译器会将该数当成long类型\n &nbsp; &nbsp;4:12.345f 或者12.345F 编译器会将该数当成float类型\n\n#### 字节码\n- **常见的字节码**\n* ASCII 码\n* GBK码\n* Unicode码【占2个字节】\n\n#### 运算符\n- **常见的运算符有哪些**\n &nbsp; &nbsp;* 算术运算符\n &nbsp; &nbsp;* 赋值运算符\n &nbsp; &nbsp;* 关系运算符\n &nbsp; &nbsp;* 逻辑运算符\n &nbsp; &nbsp;* 三目运算符\n &nbsp; &nbsp;* 特殊运算符: 位运算符\n- **算术运算符**\n+, &nbsp;-, &nbsp;*, &nbsp;/, &nbsp;%(取余), ++(自加), --(自减)\n- **赋值运算符**\n= ， += ， -= ， *= ， /= ， %=\n- **关系运算符**\n==, &gt;, &lt;, =&gt;, &lt;=, !=\n- **逻辑运算符**\n</p><p>&amp; ，^ ，| ，&amp;&amp; ，|| ，！ ， ^</p><p>- **三目运算符**\na == b ？ c ： d\n格式：(条件表达式)？表达式1：表达式2\n- **位运算符**\n&amp; , | , ^ , ~ , &lt;&lt; , &gt;&gt; , &gt;&gt;&gt;\n\n#### Java基本语句结构\n- **语句结构种类**\n &nbsp; &nbsp;* 顺序结构\n &nbsp; &nbsp;* 选择结构\n &nbsp; &nbsp;* 循环结构\n- **顺序结构**\n &nbsp; &nbsp;* 从上到下依次执行\n- **选择结构【可以嵌套】**\n &nbsp; &nbsp;* if ， if else ， if else if …… else\n &nbsp; &nbsp;* switch case【支持byte，short，char，int，String】\n- **循环结构**\n* for\nfor(初始化语句;判断条件语句;控制条件语句) {\n &nbsp; &nbsp; &nbsp; &nbsp; 循环体语句;\n}\n第一步：先执行初始化语句，只执行一次\n第二步：执行判断条件语句\n第三部：执行循环体语句\n第四步：执行控制条件语句，然后再执行循环体语句【循环】\n* while\n初始化语句;\nwhile(判断条件语句) {\n &nbsp; &nbsp;循环体语句;\n &nbsp; &nbsp;控制条件语句;\n}\n* do while\ndo {\n &nbsp; &nbsp; &nbsp; &nbsp; 循环体语句;\n}while((判断条件语句);\n\n#### Java方法\n- **定义**\n方法就是完成特定功能的代码块\n</p><p>1.系统方法，只需要会使用，不需要知道内部的结构<br>2.自定义方法: 方法内部实现需要我们来写<br>3.方法内部不能再嵌套方法</p><p>- **格式**\n修饰符 返回类型 方法名(参数类型 参数名,...){\n &nbsp; &nbsp;函数体\n &nbsp; &nbsp;return 返回值\n}\n* 修饰符: public static或者直接是public或是其他的private\n* 返回类型: 所有的数据类型(基本类型: int, long,float,char...,引用数据类型: String)\n* 方法名: 采用驼峰式,首字母一般小写,要见名知意\n* 参数类型: 所有的数据类型,如果一个方法没有返回值,则这个方法值类型为void\n* 参数名: 变量\n* 返回值: 即返回结果(这个结果必须与返回类型一致)\n\n#### 数组\n- **数组的概念**\n* 数组是一个容器,可以储存多个变量,这些变量的数据类型必须一致\n* 数组既可以储存基本数据类型,也可以储存引用数据类型\n\n- **一维数组**\n* 数组格式定义\n &nbsp; &nbsp;格式一: 数据类型【】 数组名\n &nbsp; &nbsp;格式二: 数据类型 数组名【】\nint[] a; //定义了一个int类型的数组a;\nint a[]; //定义了一个int类型的a数组;\n- 数组的初始化\n &nbsp; &nbsp;* java的数组必须初始化,然后才能使用\n &nbsp; &nbsp;* 数组初始化: 就是为数组元素中的数组分配内存空间,并为每一个数组元素赋值\n- 初始化分类\n &nbsp; &nbsp;* &nbsp;动态初始化: 只指定长度,由系统给出初始值\n &nbsp; &nbsp;* 静态初始化: 给出初始值,由系统给出长度\n &nbsp; &nbsp;* 注意事项: 这两种方式,只能给出一种,不能动静结合\n- **二维数组**\n* 数组定义格式\n &nbsp; &nbsp;* 数据类型[][] 变量名 = new 数据类型[m][n];\n &nbsp; &nbsp;* m表示这个二维数组有多少个一维数组\n &nbsp; &nbsp;* n表示每一个一维数组的元素个数\nint[][] arr = new int[3][2];\n定义了一个二维数组arr\n这个二维数组有3个一维数组，名称是arr[0],arr[1],arr[2]\n每个一维数组有2个元素，可以通过arr[m][n]来获取,\n</p><p>```</p><h4>数据结构</h4><p><strong>枚举: Enumeration</strong><br><strong>位集合: BitSet</strong><br><strong>向量: Vector</strong><br><strong>栈: Stack</strong><br><strong>字典: Dictionary</strong><br><strong>哈希表: Hashtable</strong><br><strong>属性: Properties</strong></p><ul><li>枚举:<ul><li>枚举（Enumeration）接口虽然它本身不属于数据结构,但它在其他数据结构的范畴里应用很广。</li><li>枚举（The Enumeration）接口定义了一种从数据结构中取回连续元素的方式。</li></ul></li><li>位集合（BitSet）<ul><li>位集合类实现了一组可以单独设置和清除的位或标志。</li><li>该类在处理一组布尔值的时候非常有用，你只需要给每个值赋值一”位”，<br>然后对位进行适当的设置或清除，就可以对布尔值进行操作了。</li></ul></li><li>向量（Vector）<ul><li>向量（Vector）类和传统数组非常相似，但是Vector的大小能根据需要动态的变化。<br>和数组一样，Vector对象的元素也能通过索引访问。</li><li>使用Vector类最主要的好处就是在创建对象的时候不必给对象指定大小，它的大小会根据需要动态的变化。</li></ul></li><li>栈（Stack）<ul><li>栈（Stack）实现了一个后进先出（LIFO）的数据结构。</li><li>你可以把栈理解为对象的垂直分布的栈，当你添加一个新元素时，就将新元素放在其他元素的顶部。</li><li>当你从栈中取元素的时候，就从栈顶取一个元素。换句话说，最后进栈的元素最先被取出。</li><li>字典（Dictionary）<br>字典（Dictionary） 类是一个抽象类，它定义了键映射到值的数据结构。<br>当你想要通过特定的键而不是整数索引来访问数据的时候，这时候应该使用Dictionary。<br>由于Dictionary类是抽象类，所以它只提供了键映射到值的数据结构，而没有提供特定的实现。</li></ul></li><li>哈希表（Hashtable）<br>Hashtable类提供了一种在用户定义键结构的基础上来组织数据的手段。<br>例如，在地址列表的哈希表中，你可以根据邮政编码作为键来存储和排序数据，而不是通过人名。<br>哈希表键的具体含义完全取决于哈希表的使用情景和它包含的数据。</li><li>属性（Properties）<br>Properties 继承于 Hashtable.Properties 类表示了一个持久的属性集.属性列表中每个键及其对应值都是一个字符串。<br>Properties 类被许多Java类使用。例如，在获取环境变量时它就作为System.getProperties()方法的返回值。</li></ul>', null, '1', '2019-05-29 09:50:37', '2019-05-29 09:50:37', '0');
INSERT INTO `blog` VALUES ('30', '初识数据库', '<figure class=\"image image-style-align-right\"><img src=\"/ssmBlog/uploadImage/0ff17214-211e-4cf5-bbc6-95336a75e9f1.png\"></figure><h4><strong>初识数据库</strong></h4><p><strong>什么是数据库</strong></p><p>&nbsp;</p><p>数据库（Database）是按照数据结构来组织、存储和管理数据的仓库，</p><p>每个数据库都有一个或多个不同的API用于创建，访问，管理，搜索和复制所保存的数据。</p><p>我们也可以将数据存储在文件中，但是在文件中读写数据速度相对较慢。</p><p>所以，现在我们使用关系型数据库管理系统（RDBMS）来存储和管理的大数据量。所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。<br><br>RDBMS即关系数据库管理系统(Relational Database Management System)的特点：</p><p>1.数据以表格的形式出现<br>2.每行为各种记录名称<br>3.每列为记录名称所对应的数据域<br>4.许多的行和列组成一张表单</p><p>常见的数据库</p><ul><li>Oracle</li><li>DB2</li><li>SQL server</li><li>Postgre SQL</li><li>MySql</li></ul><p>数据库相关的术语</p><ul><li>数据库系统(DataBase System): DBS<ul><li>数据库(DataBase)</li><li>数据库管理系统(DataBase Management System):DBMS</li><li>应用开发工具</li><li>管理员及用户</li></ul></li><li>SQL语言(Structured Query Language：结构化查询语言)<ul><li>DDL 数据定义语言</li><li>DML 数据操作语言</li><li>DQL 数据查询语言</li><li>DCL 数据控制语言</li></ul></li></ul><p>RDBMS 术语</p><ul><li>数据库: 数据库是一些关联表的集合。</li><li>数据表: 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。</li><li>列: 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。</li><li>行：一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。</li><li>冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性。</li><li>主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。</li><li>外键：外键用于关联两个表。</li><li>复合键：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。</li><li>索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。</li><li>参照完整性: 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。</li></ul><h4><strong>MySql 相关操作</strong></h4><ul><li>MySQL 是最流行的关系型数据库管理系统，在WEB应用方面 MySQL 是最好的RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。<br>配置下 MySQL 的配置文件my.ini</li></ul><p><strong>登录/退出MySql</strong></p><p>&nbsp;</p><ul><li>登录<ul><li>mysql -uroot -p</li><li>mysql -uroot -proot</li><li>得到版本号<br>mysql -V<br>nysql –version</li><li>登录的同时打开指定的数据库<br>mysql -uroot -p -D db_name</li></ul></li><li>退出<ul><li>exit</li><li>quit</li></ul></li><li>登录信息中需要掌握的<ul><li>命令行结束符默认使用; 或者\\g来结束</li><li>可以通过help或者\\h或者?加上关键字来查看手册</li><li>\\c可以取消当前命令的执行<strong>SQL语句语法规范</strong></li></ul></li></ul><p>&nbsp;</p><ul><li>常用的MySQL的关键字我们需要大写,库名,表名,字段名称等使用小写</li><li>SQL语句支持折行操作,拆分的时候不能把完整单词拆开</li><li>数据库名称,表名称,字段名称不要使用MySQL的保留字,如果必须要使用,需要加反引号 将其括起来<strong>常用的SQL语句</strong></li></ul><p>&nbsp;</p><p>获取登录的用户</p><p>获取MySQl的版本信息</p><p>获取当前的日期信息</p><p>获取当前打开的数据库</p><h4><strong>创建数据库</strong></h4><figure class=\"table\"><table><tbody><tr><td>1<br>2<br>3<br>4<br>&nbsp;</td><td>//方式一<br>CREATE DATABASE db_name;<br>//方式二<br>CREATE SCHEMA db_name;<br>&nbsp;</td></tr></tbody></table></figure><p>检测数据库名称是否存在,不存在就创建</p><p>在创建数据库的同时制定编码方式</p><p>注意:<br>数据库名称最好有意义<br>名称中不能包含特殊字符或者是Mysql关键字</p><p>查看当前服务器下全部数据库</p><p>查看指定数据的详细信息</p><p>修改指定数据库的编码方式</p><p>打开指定的数据库</p><p>获取当前打开的数据库</p><p>删除指定的数据库</p><p>查看警告</p><h4><strong>数据库支持的类型</strong></h4><ul><li>1.整数类<br>help tinyint查看详细信息<br>\\h INT</li><li>2.浮点类型<br>FLOAT<br>DOUBLE<br>DECIMAL和double一样，内部以字符串形式存储</li><li>3.字符串类型<br>CHAR 定长字符串<br>VARCHAR 变长字符串<br>TEXT 文本字符串<br>ENUM:枚举(可用于性别)<br>SET<br>。。。</li><li>4.日期时间类<br>TIME<br>DATE<br>DATETIME<br>TIMESTAMP<br>YEAR<br>整型保存时间戳</li><li>5.二进制类(用的少)</li></ul><h4><strong>数据表</strong></h4><p>创建数据表</p><p>完整性约束条件：</p><ul><li>PRIMARY KEY 主键</li><li>AUTO_INCREMENT 自增长</li><li>FOREIGN KEY 外键</li><li>NOT NULL 非空</li><li>UNIQUE KEY 唯一</li><li>DEFAULT 默认值</li></ul><figure class=\"table\"><table><tbody><tr><td>1<br>2<br>3<br>&nbsp;</td><td>CREATE TABLE [IF NOT EXISTS] tbl_name(<br>		字段名称 字段类型 [完整性约束条件]<br>	)ENGINE=引擎名称CHARSET=\'编码方式\';<br>&nbsp;</td></tr></tbody></table></figure><figure class=\"table\"><table><tbody><tr><td>1<br>&nbsp;</td><td>SHOW WARNINGS;<br>&nbsp;</td></tr></tbody></table></figure><figure class=\"table\"><table><tbody><tr><td>1<br>2<br>3<br>&nbsp;</td><td>DROP DATABASE db_name;<br>//如果数据库存在<br>DROP DATABASE [IF EXISTS] db_name;<br>&nbsp;</td></tr></tbody></table></figure><figure class=\"table\"><table><tbody><tr><td>1<br>2<br>3<br>4<br>&nbsp;</td><td>//方式一<br>	SELECT DATABASE();<br>//方式二<br>	SELECT SCHEMA();<br>&nbsp;</td></tr></tbody></table></figure><figure class=\"table\"><table><tbody><tr><td>1<br>&nbsp;</td><td>USE db_name;<br>&nbsp;</td></tr></tbody></table></figure><figure class=\"table\"><table><tbody><tr><td>1<br>2<br>3<br>&nbsp;</td><td>ALTER DATABASE db_name [DEFAULT] CHARACTER SET [=] charset;<br><br>ALTER DATABASE db_name [DEFAULT] CAHRACTER SET [=] charset;<br>&nbsp;</td></tr></tbody></table></figure><figure class=\"table\"><table><tbody><tr><td>1<br>&nbsp;</td><td>SHOW CREATE DATABASE db_name;<br>&nbsp;</td></tr></tbody></table></figure><figure class=\"table\"><table><tbody><tr><td>1<br>2<br>3<br>4<br>&nbsp;</td><td>//方式一<br>SHOW DATABASES;<br>//方式二<br>SHOW SCHEMAS;<br>&nbsp;</td></tr></tbody></table></figure><figure class=\"table\"><table><tbody><tr><td>1<br>&nbsp;</td><td>CREATE DATABASE [IF NOT EXISTS] db_name [DEFAULT] CHARACTER SET [=] charset;<br>&nbsp;</td></tr></tbody></table></figure><figure class=\"table\"><table><tbody><tr><td>1<br>2<br>&nbsp;</td><td>CREATE DATABASE [IF NOT EXISTS] db_name;&nbsp;<br>//方括号中的(可选)可写可不写<br>&nbsp;</td></tr></tbody></table></figure><figure class=\"table\"><table><tbody><tr><td>1<br>&nbsp;</td><td>SELECT DATABASE()<br>&nbsp;</td></tr></tbody></table></figure><figure class=\"table\"><table><tbody><tr><td>1<br>&nbsp;</td><td>SELECT NOW()<br>&nbsp;</td></tr></tbody></table></figure><figure class=\"table\"><table><tbody><tr><td>1<br>&nbsp;</td><td>SELECT VERSION()<br>&nbsp;</td></tr></tbody></table></figure><figure class=\"table\"><table><tbody><tr><td>1<br>&nbsp;</td><td>SELECT USER()<br>&nbsp;</td></tr></tbody></table></figure><figure class=\"table\"><table><tbody><tr><td>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>&nbsp;</td><td>[mysql]<br># 设置mysql客户端默认字符集<br>default-character-set=utf8<br>&nbsp;<br>[mysqld]<br># 设置3306端口<br>port = 3306<br># 设置mysql的安装目录<br>basedir=C:\\\\web\\\\mysql-8.0.11<br># 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错<br># datadir=C:\\\\web\\\\sqldata<br># 允许最大连接数<br>max_connections=20<br># 服务端使用的字符集默认为8比特编码的latin1字符集<br>character-set-server=utf8<br># 创建新表时将使用的默认存储引擎<br>default-storage-engine=INNODB<br>&nbsp;</td></tr></tbody></table></figure>', null, '2', '2019-05-29 09:57:43', '2019-05-29 09:57:43', '0');

-- ----------------------------
-- Table structure for `category`
-- ----------------------------
DROP TABLE IF EXISTS `category`;
CREATE TABLE `category` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `typeName` varchar(20) NOT NULL DEFAULT '' COMMENT '文章类型',
  `status` int(11) NOT NULL DEFAULT '0' COMMENT '状态: 0为显示,1为隐藏',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of category
-- ----------------------------
INSERT INTO `category` VALUES ('1', 'java', '0');
INSERT INTO `category` VALUES ('2', 'JavaScript', '0');
INSERT INTO `category` VALUES ('3', 'react', '0');
INSERT INTO `category` VALUES ('4', 'mysql', '0');
INSERT INTO `category` VALUES ('5', 'node', '0');
INSERT INTO `category` VALUES ('6', 'css', '0');

-- ----------------------------
-- Table structure for `u_permission`
-- ----------------------------
DROP TABLE IF EXISTS `u_permission`;
CREATE TABLE `u_permission` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `permissionName` varchar(50) DEFAULT NULL,
  `roleId` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `roleId` (`roleId`),
  CONSTRAINT `u_permission_ibfk_1` FOREIGN KEY (`roleId`) REFERENCES `u_role` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of u_permission
-- ----------------------------
INSERT INTO `u_permission` VALUES ('1', 'user:*', '1');
INSERT INTO `u_permission` VALUES ('2', 'admin:*', '2');
INSERT INTO `u_permission` VALUES ('3', 'user:*', '3');

-- ----------------------------
-- Table structure for `u_role`
-- ----------------------------
DROP TABLE IF EXISTS `u_role`;
CREATE TABLE `u_role` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `roleName` varchar(255) DEFAULT NULL COMMENT '角色名称',
  `roleType` varchar(255) DEFAULT '' COMMENT '角色类型',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of u_role
-- ----------------------------
INSERT INTO `u_role` VALUES ('1', 'user', '1');
INSERT INTO `u_role` VALUES ('2', 'vip', '2');
INSERT INTO `u_role` VALUES ('3', 'admin', '3');

-- ----------------------------
-- Table structure for `u_user`
-- ----------------------------
DROP TABLE IF EXISTS `u_user`;
CREATE TABLE `u_user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(255) NOT NULL COMMENT '用户名',
  `password` varchar(255) NOT NULL COMMENT '密码',
  `roleId` int(11) DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL COMMENT '邮箱',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '修改时间',
  `status` bigint(20) NOT NULL DEFAULT '1' COMMENT '1:有效，0:禁止登录',
  PRIMARY KEY (`id`),
  KEY `roleId` (`roleId`),
  CONSTRAINT `u_user_ibfk_1` FOREIGN KEY (`roleId`) REFERENCES `u_role` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=24 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of u_user
-- ----------------------------
INSERT INTO `u_user` VALUES ('23', 'admin', 'c8e1188ed1f027f48fa091281f5235b4', '1', '276248772@qq.com', '2019-05-13 19:23:36', '2019-05-13 19:23:36', '1');

-- ----------------------------
-- Procedure structure for `init_shiro_demo`
-- ----------------------------
DROP PROCEDURE IF EXISTS `init_shiro_demo`;
DELIMITER ;;
CREATE DEFINER=`root`@`%` PROCEDURE `init_shiro_demo`()
BEGIN	
/*
SQLyog 企业版 - MySQL GUI v7.14 
MySQL - 5.6.16-log : Database - 
*********************************************************************
*/
/*表结构插入*/
DROP TABLE IF EXISTS `u_permission`;
CREATE TABLE `u_permission` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `url` varchar(256) DEFAULT NULL COMMENT 'url地址',
  `name` varchar(64) DEFAULT NULL COMMENT 'url描述',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=21 DEFAULT CHARSET=utf8;
/*Table structure for table `u_role` */
DROP TABLE IF EXISTS `u_role`;
CREATE TABLE `u_role` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(32) DEFAULT NULL COMMENT '角色名称',
  `type` varchar(10) DEFAULT NULL COMMENT '角色类型',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;
/*Table structure for table `u_role_permission` */
DROP TABLE IF EXISTS `u_role_permission`;
CREATE TABLE `u_role_permission` (
  `rid` bigint(20) DEFAULT NULL COMMENT '角色ID',
  `pid` bigint(20) DEFAULT NULL COMMENT '权限ID'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*Table structure for table `u_user` */
DROP TABLE IF EXISTS `u_user`;
CREATE TABLE `u_user` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `nickname` varchar(20) DEFAULT NULL COMMENT '用户昵称',
  `email` varchar(128) DEFAULT NULL COMMENT '邮箱|登录帐号',
  `pswd` varchar(32) DEFAULT NULL COMMENT '密码',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `last_login_time` datetime DEFAULT NULL COMMENT '最后登录时间',
  `status` bigint(1) DEFAULT '1' COMMENT '1:有效，0:禁止登录',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8;
/*Table structure for table `u_user_role` */
DROP TABLE IF EXISTS `u_user_role`;
CREATE TABLE `u_user_role` (
  `uid` bigint(20) DEFAULT NULL COMMENT '用户ID',
  `rid` bigint(20) DEFAULT NULL COMMENT '角色ID'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*
SQLyog 企业版 - MySQL GUI v7.14 
MySQL - 5.6.16-log : Database - i_wenyiba_com
*********************************************************************
*/
/*所有的表数据插入*/
/*Data for the table `u_permission` */
insert  into `u_permission`(`id`,`url`,`name`) values (4,'/permission/index.shtml','权限列表'),(6,'/permission/addPermission.shtml','权限添加'),(7,'/permission/deletePermissionById.shtml','权限删除'),(8,'/member/list.shtml','用户列表'),(9,'/member/online.shtml','在线用户'),(10,'/member/changeSessionStatus.shtml','用户Session踢出'),(11,'/member/forbidUserById.shtml','用户激活&禁止'),(12,'/member/deleteUserById.shtml','用户删除'),(13,'/permission/addPermission2Role.shtml','权限分配'),(14,'/role/clearRoleByUserIds.shtml','用户角色分配清空'),(15,'/role/addRole2User.shtml','角色分配保存'),(16,'/role/deleteRoleById.shtml','角色列表删除'),(17,'/role/addRole.shtml','角色列表添加'),(18,'/role/index.shtml','角色列表'),(19,'/permission/allocation.shtml','权限分配'),(20,'/role/allocation.shtml','角色分配');
/*Data for the table `u_role` */
insert  into `u_role`(`id`,`name`,`type`) values (1,'系统管理员','888888'),(3,'权限角色','100003'),(4,'用户中心','100002');
/*Data for the table `u_role_permission` */
insert  into `u_role_permission`(`rid`,`pid`) values (4,8),(4,9),(4,10),(4,11),(4,12),(3,4),(3,6),(3,7),(3,13),(3,14),(3,15),(3,16),(3,17),(3,18),(3,19),(3,20),(1,4),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(1,12),(1,13),(1,14),(1,15),(1,16),(1,17),(1,18),(1,19),(1,20);
/*Data for the table `u_user` */
insert  into `u_user`(`id`,`nickname`,`email`,`pswd`,`create_time`,`last_login_time`,`status`) values (1,'管理员','admin','9c3250081c7b1f5c6cbb8096e3e1cd04','2016-06-16 11:15:33','2016-06-16 11:24:10',1),(11,'soso','8446666@qq.com','d57ffbe486910dd5b26d0167d034f9ad','2016-05-26 20:50:54','2016-06-16 11:24:35',1),(12,'8446666','8446666','4afdc875a67a55528c224ce088be2ab8','2016-05-27 22:34:19','2016-06-15 17:03:16',1);
/*Data for the table `u_user_role` */
insert  into `u_user_role`(`uid`,`rid`) values (12,4),(11,3),(11,4),(1,1);
   
    END
;;
DELIMITER ;
